<!DOCTYPE html>
<html>
<head>
<style>
	@import url("styles/juneau-code.css");
	@import url("styles/juneau-doc.css");
</style>
</head>
<body>
	<h5 class='toc'>About</h5>
	<ul class='spaced-list'>
		<li>A toolkit for marshalling POJOs to a wide variety of content types using a common framework.
		<li>A REST server API for creating Swagger-based self-documenting REST interfaces using POJOs.
		<li>A REST client API for interacting with REST interfaces using POJOs.
		<li>A remote proxy API built on top of REST.
		<li>A sophisticated INI config file API. 
		<li>A REST microservice API that combines all the features above for creating lightweight standalone REST interfaces that start up in milliseconds.
	</ul>
	<h5 class='toc'>Examples</h5>
	<p>
		Core library includes easy-to-use and customizable serializers and parsers.  The examples here are only a small taste of what's possible. 
		Many examples are provided in the Javadocs.
	</p>
	<p>
		The default serializers can often be used to serializers POJOs in a single line of code...
	</p>
	<p class='bcode'>
	<jc>// A simple POJO class</jc>
	<jk>public class</jk> Person {
		<jk>public</jk> String name = <js>"John Smith"</js>;
		<jk>public int</jk> age = 21;
	}
	
	<jc>// Serialize a bean to JSON, XML, or HTML</jc>
	Person p = <jk>new</jk> Person();
	
	<jc>// Produces:
	// "{name:'John Smith',age:21}"</jc>
	String json = JsonSerializer.<jsf>DEFAULT_LAX</jsf>.serialize(p);
	
	<jc>// Produces:
	// "{"name":"John Smith","age":21}"</jc>
	String json = JsonSerializer.<jsf>DEFAULT</jsf>.serialize(p);
	
	<jc>// Produces:
	// &lt;object&gt;
	//   &lt;name&gt;John Smith&lt;/name&gt;
	//   &lt;age&gt;21&lt;/age&gt;
	// &lt;/object&gt;&lt;</jc>
	String xml = XmlSerializer.<jsf>DEFAULT_SIMPLE</jsf>.serialize(p);
	
	<jc>// Produces:
	// &lt;table&gt;
	//   &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;John Smith&lt;/td&gt;&lt;/tr&gt;
	//   &lt;tr&gt;&lt;td&gt;age&lt;/td&gt;&lt;td&gt;21&lt;/td&gt;&lt;/tr&gt;
	// &lt;/table&gt;</jc>
	String html = HtmlSerializer.<jsf>DEFAULT</jsf>.serialize(p);
	
	<jc>// Produces:
	// name=John+Smith&amp;age=$n(21)</jc>
	String urlEncoding = UrlEncodingSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// $o(name=John Smith,age=$n(21))</jc>
	String uon = UonSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// 82 A4 name AA 4A John Smith 68 A3 age 15</jc>
	<jk>byte</jk>[] messagePack = MsgPackSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// &lt;rdf:RDF
	//  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	//  xmlns:jp="http://www.ibm.com/juneaubp/"
	//  xmlns:j="http://www.ibm.com/juneau/"&gt;
	// 	&lt;rdf:Description&gt;
	// 		&lt;jp:name&gt;John Smith&lt;/jp:name&gt;
	// 		&lt;jp:age&gt;21&lt;/jp:age&gt;
	// 	&lt;/rdf:Description&gt;
	// &lt;/rdf:RDF&gt;</jc>
	String rdfXml = RdfSerializer.<jsf>DEFAULT_XMLABBREV</jsf>.serialize(p);
	
	<jc>// Produces:
	// @prefix jp:      &lt;http://www.ibm.com/juneaubp/&gt; .
	// @prefix j:       &lt;http://www.ibm.com/juneau/&gt; .
	//	[]    jp:age  "21" ;
	//	      jp:name "John Smith" .</jc>
	String rdfN3 = RdfSerializer.<jsf>DEFAULT_N3</jsf>.serialize(p);

	<jc>// Produces:
	// _:A3bf53c85X3aX157cf407e2dX3aXX2dX7ffd &lt;http://www.ibm.com/juneaubp/name&gt; "John Smith" .
	// _:A3bf53c85X3aX157cf407e2dX3aXX2dX7ffd &lt;http://www.ibm.com/juneaubp/age&gt; "21" .</jc>
	String rdfNTriple = RdfSerializer.<jsf>DEFAULT_NTRIPLE</jsf>.serialize(p);
	</p>
	<p>
		Parsing back into POJOs is equally simple...
	</p>
	<p class='bcode'>
	<jc>// Use one of the predefined parsers.</jc>
	ReaderParser parser = JsonParser.<jsf>DEFAULT</jsf>;
	
	<jc>// Parse a JSON object (creates a generic ObjectMap).</jc>
	String json = <js>"{name:'John Smith',age:21}"</js>;
	Map m1 = parser.parse(json, Map.<jk>class</jk>);
	
	<jc>// Parse a JSON string.</jc>
	json = <js>"'foobar'"</js>;
	String s2 = parser.parse(json, String.<jk>class</jk>);
	
	<jc>// Parse a JSON number as a Long or Float.</jc>
	json = <js>"123"</js>;
	Long l3 = parser.parse(json, Long.<jk>class</jk>);
	Float f3 = parser.parse(json, Float.<jk>class</jk>);
	
	<jc>// Parse a JSON object as a bean.</jc>
	json = <js>"{name:'John Smith',age:21}"</js>;
	Person p4 = parser.parse(json, Person.<jk>class</jk>);
	
	<jc>// Parse a JSON object as a HashMap&lt;String,Person&gt;.</jc>
	json = <js>"{a:{name:'John Smith',age:21},b:{name:'Joe Smith',age:42}}"</js>;
	Map&lt;String,Person&gt; m5 = parser.parseMap(json, HashMap.<jk>class</jk>, String.<jk>class</jk>, Person.<jk>class</jk>)
	
	<jc>// Parse a JSON array of integers as a Collection of Integers or int[] array.</jc>
	json = <js>"[1,2,3]"</js>;
	List&lt;Integer&gt; l6 = parser.parseCollection(json, LinkedList.<jk>class</jk>, Integer.<jk>class</jk>);
	<jk>int</jk>[] i6 = parser.parse(json, <jk>int</jk>[].<jk>class</jk>);
	</p>
	<p>
		Many POJOs such as primitives, beans, collections, arrays, and classes with various known constructors and methods are serializable out-of-the-box.  
		For other objects, "swaps" allow you to swap-in serializable replacement objects during serialization
		and vis-versa during parsing.  Beans can also be tailored in various ways.  
	</p>
	<p>
		<code>SerializerGroup</code> and <code>ParserGroup</code> classes allow serializers and parsers 
		to be retrieved by W3C-compliant HTTP <code>Accept</code> and <code>Content-Type</code> values...
	</p>
	<p class='bcode'>
	<jc>// Construct a new serializer group with configuration parameters that get applied to all serializers.</jc>
	SerializerGroup sg = <jk>new</jk> SerializerGroup()
		.append(JsonSerializer.<jk>class</jk>, UrlEncodingSerializer.<jk>class</jk>);
		.setProperty(SerializerContext.<jsf>SERIALIZER_useIndentation</jsf>, <jk>true</jk>)
		.addPojoSwaps(CalendarSwap.ISO8601DT.<jk>class</jk>);

	<jc>// Find the appropriate serializer by Accept type and serialize our POJO to the specified writer.</jc>
	sg.getSerializer(<js>"text/invalid, text/json;q=0.8, text/*;q:0.6, *\/*;q=0.0"</js>)
		.serialize(myPersonObject, myWriter);
		
	<jc>// Construct a new parser group with configuration parameters that get applied to all parsers.</jc>
	ParserGroup pg = <jk>new</jk> ParserGroup()
		.append(JsonSerializer.<jk>class</jk>, UrlEncodingSerializer.<jk>class</jk>);
 		.addPojoSwaps(CalendarSwap.ISO8601DT.<jk>class</jk>);

	Person p = pg.getParser(<js>"text/json"</js>).parse(myReader, Person.<jk>class</jk>);
	</p>
	<p>
		The REST server API builds upon the <code>SerializerGroup</code> and <code>ParserGroup</code> classes 
		to provide annotated REST servlets that automatically negotiate the HTTP media types and allow the developer
		to work with requests, responses, headers, path variables, query parameters, and form data as POJOs.
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/systemProperties"</js>,
		title=<js>"System properties resource"</js>,
		description=<js>"REST interface for performing CRUD operations on system properties."</js>,
		properties={
			<ja>@Property</ja>(name=<jsf>SERIALIZER_quoteChar</jsf>, value=<js>"'"</js>),
			<ja>@Property</ja>(name=<jsf>HTMLDOC_links</jsf>, value=<js>"{up:'$R{requestParentURI}',options:'$R{servletURI}?method=OPTIONS'}"</js>),
		},
		stylesheet=<js>"styles/devops.css"</js>,
		encoders=GzipEncoder.<jk>class</jk>,
		contact=<js>"{name:'John Smith',email:'john@smith.com'}"</js>,
		license=<js>"{name:'Apache 2.0',url:'http://www.apache.org/licenses/LICENSE-2.0.html'}"</js>,
		version=<js>"2.0"</js>,
		termsOfService=<js>"You're on your own."</js>,
		tags=<js>"[{name:'Java',description:'Java utility',externalDocs:{description:'Home page',url:'http://juneau.apache.org'}}]"</js>,
		externalDocs=<js>"{description:'Home page',url:'http://juneau.apache.org'}"</js>
	)
	<jk>public class</jk> SystemPropertiesResource <jk>extends</jk> RestServletDefault {
	
		<ja>@RestMethod</ja>(
			name=<js>"GET"</js>, path=<js>"/"</js>,
			summary=<js>"Show all system properties"</js>,
			description=<js>"Returns all system properties defined in the JVM."</js>,
			parameters={
				<ja>@Parameter</ja>(in=<js>"query"</js>, name=<js>"sort"</js>, description=<js>"Sort results alphabetically."</js>, _default=<js>"false"</js>)
			},
			responses={
				<ja>@Response</ja>(value=200, description=<js>"Returns a map of key/value pairs."</js>)
			}
		)
		<jk>public</jk> Map getSystemProperties(<ja>@Query</ja>(<js>"sort"</js>) <jk>boolean</jk> sort) <jk>throws</jk> Throwable {
			<jk>if</jk> (sort)
				<jk>return new</jk> TreeMap(System.<jsm>getProperties</jsm>());
			<jk>return</jk> System.<jsm>getProperties</jsm>();
		}
	
		<ja>@RestMethod</ja>(
			name=<js>"GET"</js>, path=<js>"/{propertyName}"</js>,
			summary=<js>"Get system property"</js>,
			description=<js>"Returns the value of the specified system property."</js>,
			parameters={
				<ja>@Parameter</ja>(in=<js>"path"</js>, name=<js>"propertyName"</js>, description=<js>"The system property name."</js>)
			},
			responses={
				<ja>@Response</ja>(value=200, description=<js>"The system property value, or null if not found."</js>)
			}
		)
		<jk>public</jk> String getSystemProperty(<ja>@Path</ja> String propertyName) <jk>throws</jk> Throwable {
			<jk>return</jk> System.<jsm>getProperty</jsm>(propertyName);
		}
	
		<ja>@RestMethod</ja>(
			name=<js>"PUT"</js>, path=<js>"/{propertyName}"</js>, 
			summary=<js>"Replace system property"</js>,
			description=<js>"Sets a new value for the specified system property."</js>,
			guards=AdminGuard.<jk>class</jk>,
			parameters={
				<ja>@Parameter</ja>(in=<js>"path"</js>, name=<js>"propertyName"</js>, description=<js>"The system property name."</js>),
				<ja>@Parameter</ja>(in=<js>"body"</js>, description=<js>"The new system property value."</js>),
			},
			responses={
				<ja>@Response</ja>(value=302, 
					headers={
						<ja>@Parameter</ja>(name=<js>"Location"</js>, description=<js>"The root URL of this resource."</js>)
					}
				),	
				<ja>@Response</ja>(value=403, description=<js>"User is not an admin."</js>) 
			}
		)
		<jk>public</jk> Redirect setSystemProperty(<ja>@Path</ja> String propertyName, <ja>@Body</ja> String value) {
			System.<jsm>setProperty</jsm>(propertyName, value);
			<jk>return new</jk> Redirect();
		}
	
		<ja>@RestMethod</ja>(
			name=<js>"POST"</js>, path=<js>"/"</js>, 
			summary=<js>"Add an entire set of system properties"</js>,
			description=<js>"Takes in a map of key/value pairs and creates a set of new system properties."</js>,
			guards=AdminGuard.<jk>class</jk>,
			parameters={
				<ja>@Parameter</ja>(in=<js>"path"</js>, name=<js>"propertyName"</js>, description=<js>"The system property key."</js>),
				<ja>@Parameter</ja>(in=<js>"body"</js>, description=<js>"The new system property values.", schema="{example:{key1:'val1',key2:123}}"</js>),
			},
			responses={
				<ja>@Response</ja>(value=302, 
					headers={
						<ja>@Parameter</ja>(name=<js>"Location"</js>, description=<js>"The root URL of this resource."</js>)
					}
				),	
				<ja>@Response</ja>(value=403, description=<js>"Unauthorized:  User is not an admin."</js>) 
			}
		)
		<jk>public</jk> Redirect setSystemProperties(<ja>@Body</ja> java.util.Properties newProperties) {
			System.<jsm>setProperties</jsm>(newProperties);
			<jk>return new</jk> Redirect();
		}
	
		<ja>@RestMethod</ja>(
			name=<js>"DELETE"</js>, path=<js>"/{propertyName}"</js>, 
			summary=<js>"Delete system property"</js>,
			description=<js>"Deletes the specified system property."</js>,
			guards=AdminGuard.<jk>class</jk>,
			parameters={
				<ja>@Parameter</ja>(in=<js>"path"</js>, name=<js>"propertyName"</js>, description=<js>"The system property name."</js>),
			},
			responses={
				<ja>@Response</ja>(value=302, 
					headers={
						<ja>@Parameter</ja>(name=<js>"Location"</js>, description=<js>"The root URL of this resource."</js>)
					}
				),	
				<ja>@Response</ja>(value=403, description=<js>"Unauthorized:  User is not an admin"</js>) 
			}
		)
		<jk>public</jk> Redirect deleteSystemProperty(<ja>@Path</ja> String propertyName) {
			System.<jsm>clearProperty</jsm>(propertyName);
			<jk>return new</jk> Redirect();
		}
	
		<ja>@RestMethod</ja>(
			name=<js>"OPTIONS"</js>, path=<js>"/*"</js>,
			summary=<js>"Show resource options"</js>,
			description=<js>"Show resource options as a Swagger doc"</js>
		)
		<jk>public</jk> Swagger getOptions(RestRequest req) {
			<jk>return</jk> req.getSwagger();
		}
	}
	</p>
	<p>
		Auto-generated OPTIONS pages are constructed from Swagger DTO beans.
	</p>
	<img class='bordered' src='images/Swagger.png'>
	<p>
		The server API is based on JEE servlets, making them easy to deploy in any JEE environment.
	</p>
	<p>
		Features include: 
	</p> 
	<ul>
		<li>Extremely simple debuggability using nothing more than your browser.
		<li>Auto-generated Swagger-based OPTIONS pages from data provided through annotations (as above), resource bundles, or Swagger JSON files.
		<li>Configurability through external INI files.
		<li>Client-versioned responses (and other heuristic matching APIs).
		<li>Servlet and method level guards.
		<li>Automated error handling.
		<li>much more!....
	</ul>
	<p>
		The REST client API allows you to access REST interfaces using POJOs...
	</p>
	<p class='bcode'>
	<jc>// Create a reusable JSON client.</jc>
	RestClient client = <jk>new</jk> RestClient(JsonSerializer.<jk>class</jk>, JsonParser.<jk>class</jk>);
	
	<jc>// The address of the root resource.</jc>
	String url = <js>"http://localhost:10000/systemProperties"</js>;
	
	<jc>// Do a REST GET against a remote REST interface and convert
	// the response to an unstructured ObjectMap object.</jc>
	Map m1 = client.doGet(url).getResponse(TreeMap.<jk>class</jk>);
	
	<jc>// Add some new system properties.
	// Use XML as the transport medium.</jc>
	client = <jk>new</jk> RestClient(XmlSerializer.<jk>class</jk>, XmlParser.<jk>class</jk>);
	Properties p = <jk>new</jk> Properties();
	p.load(reader);
	<jk>int</jk> returnCode = client.doPost(url + <js>"/systemProperties"</js>, p).execute();
	</p>
	<p>
		The remote proxy interface API allows you to invoke POJO methods using REST...
	</p>
	<p class='bcode'>
	RestClient client = <jk>new</jk> RestClient(JsonSerializer.<js>class</js>, JsonParser.<js>class</js>)
		.setRemoteableUriServletUrl(<js>"https://localhost:9443/jazz/remote"</js>);
	 	
 	<jc>// Execute a method on the server.</jc>
 	IAddressBook ab = client.getRemoteableProxy(IAddressBook.<jk>class</jk>);
 	ab.createPerson(...);
	</p> 
	<p>
		Since the remote proxy API is built on top of REST, it can be debugged using nothing more than a browser.
	</p>

	<p>
		The config file API allows you to interact with INI files using POJOs.  
		A sophisticated variable language is provided for referencing environment variables, system properties, other config file entries, and a host of other types.
	<p>
	<p class='bcode'>
	<cc>#--------------------------</cc>
	<cc># My section</cc>
	<cc>#--------------------------</cc>
	<cs>[MySection]</cs>
	
	<cc># An integer</cc>
	<ck>anInt</ck> = <cv>1</cv> 
	
	<cc># A boolean</cc>
	<ck>aBoolean</ck> = <cv>true</cv>
	
	<cc># An int array</cc>
	<ck>anIntArray</ck> = <cv>1,2,3</cv>
	
	<cc># A POJO that can be converted from a String</cc>
	<ck>aURL</ck> = <cv>http://foo </cv>
	
	<cc># A POJO that can be converted from JSON</cc>
	<ck>aBean</ck> = <cv>{foo:'bar',baz:123}</cv>
	
	<cc># A system property</cc>
	<ck>locale</ck> = <cv>$S{java.locale, en_US}</cv>
	
	<cc># An environment variable</cc>
	<ck>path</ck> = <cv>$E{PATH, unknown}</cv>
	
	<cc># A manifest file entry</cc>
	<ck>mainClass</ck> = <cv>$MF{Main-Class}</cv>
	
	<cc># Another value in this config file</cc>
	<ck>sameAsAnInt</ck> = <cv>$C{MySection/anInt}</cv>
	
	<cc># A command-line argument in the form "myarg=foo"</cc>
	<ck>myArg</ck> = <cv>$ARG{myarg}</cv>
	
	<cc># The first command-line argument</cc>
	<ck>firstArg</ck> = <cv>$ARG{0}</cv>

	<cc># Look for system property, or env var if that doesn't exist, or command-line arg if that doesn't exist.</cc>
	<ck>nested</ck> = <cv>$S{mySystemProperty,$E{MY_ENV_VAR,$ARG{0}}}</cv>

	<cc># A POJO with embedded variables</cc>
	<ck>aBean2</ck> = <cv>{foo:'$ARG{0}',baz:$C{MySection/anInt}}</cv>

		</p>
		<p class='bcode'>
	<jc>// Load our config file</jc>
	ConfigFile f = ConfigMgr.<jsf>DEFAULT</jsf>.get(<js>"MyIniFile.cfg"</js>);
	
	<jk>int</jk> anInt = cf.getInt(<js>"MySection/anInt"</js>); 
	<jk>boolean</jk> aBoolean = cf.getBoolean(<js>"MySection/aBoolean"</js>); 
	<jk>int</jk>[] anIntArray = cf.getObject(<jk>int</jk>[].<jk>class</jk>, <js>"MySection/anIntArray"</js>); 
	URL aURL = cf.getObject(URL.<jk>class</jk>, <js>"MySection/aURL"</js>); 
	MyBean aBean = cf.getObject(MyBean.<jk>class</jk>, <js>"MySection/aBean"</js>); 
	Locale locale = cf.getObject(Locale.<jk>class</jk>, <js>"MySection/locale"</js>); 
	String path = cf.getString(<js>"MySection/path"</js>); 
	String mainClass = cf.getString(<js>"MySection/mainClass"</js>); 
	<jk>int</jk> sameAsAnInt = cf.getInt(<js>"MySection/sameAsAnInt"</js>); 
	String myArg = cf.getString(<js>"MySection/myArg"</js>); 
	String firstArg = cf.getString(<js>"MySection/firstArg"</js>); 
	</p>
	<p>
		The microservice API combines all the features above with a built-in Jetty server to produce a lightweight 
		REST service packaged as two simple files:
	</p>
	<ul>
		<li>An executable jar file that starts up a REST interface in milliseconds.
		<li>An external INI file that can be used to configure your REST resources on the fly.
	</ul>
	<p>
		The microservice API was originally designed for and particularly suited for use as Docker images.
	</p>

	<h5 class='toc'>Serialization languages</h5>
	<p>
		Full round-trip lossless serialization is provided for the following languages:
	</p>
	<ul>
		<li>JSON (including variants)
		<li>XML
		<li>HTML
		<li>URL-Encoding
		<li>UON (URL-Encoded Object Notation)
		<li>MessagePack
		<li>RDF/XML (including abbreviated)
		<li>N-Triple
		<li>Turtle
		<li>N3
		<li>SOAP/XML
	</ul>

	<h5 class='toc'>Data transfer objects</h5>
	<p>
		Data transfer objects that can be serialized to any of the supported languages is provided for the following models:
	</p>
	<ul>
		<li>Atom
		<li>Cognos
		<li>JSON-Schema
		<li>HTML 5
		<li>Swagger 2.0
	</ul>
</body>
</html>