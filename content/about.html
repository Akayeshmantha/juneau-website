<!DOCTYPE html>
<html>
<head>
<style>
	@import url("styles/juneau-code.css");
	@import url("styles/juneau-doc.css");
</style>
</head>
<body>
	<h5 class='toc'>About</h5>
	<p>
		A single cohesive framework consisting of the following parts:
	</p>
	<ul class='spaced-list'>
		<li>A universal toolkit for marshalling POJOs to a wide variety of content types using a common framework.
		<li>A universal REST server API for creating Swagger-based self-documenting REST interfaces using POJOs, simply deployed as 
			one or more top-level servlets in any Servlet 3.1.0+ container. 
		<li>A universal REST client API for interacting with Juneau or 3rd-party REST interfaces using POJOs and proxy interfaces.
		<li>A sophisticated configuration file API.
		<li>A REST microservice API that combines all the features above with a simple configurable Jetty server for 
			creating lightweight standalone REST interfaces that start up in milliseconds.
	</ul>
	<p>
		Questions via email to <a class='doclink' href='mailto:dev@juneau.apache.org?Subject=Apache%20Juneau%20question'>dev@juneau.apache.org</a> are always welcome.
	</p>
	<p>
		Juneau is packed with features that may not be obvious at first.  
		Users are encouraged to ask for code reviews by providing links to specific source files such as through GitHub.
		Not only can we help you with feedback, but it helps us understand usage patterns to further improve the product.
	</p>
	<h5 class='toc'>Features</h5>
	<ul class='spaced-list'>
		<li>Marshalling support for:
			<ul>
				<li>JSON (including variants, lax syntax, support for comments, fully RFC1759 compliant, plus JSON-Schema)
				<li>XML (including namespace support, plus XML-Schema)
				<li>HTML (plus HTML-Schema)
				<li>URL-Encoding
				<li>UON (URL-Encoded Object Notation)
				<li>MessagePack
				<li>RDF/XML
				<li>RDF/XML-Abbrev 
				<li>N-Triple
				<li>Turtle
				<li>N3
				<li>CSV
				<li>SOAP/XML
				<li>Coming soon: Protobuf, YAML, BSON
			</ul>
		<li>Data Transfer Objects for:
			<ul>
				<li>HTML5
				<li>Atom
				<li>Cognos
				<li>JSON-Schema
				<li>Swagger 2.0
			</ul>
		<li>KISS is our mantra!  No auto-wiring.  No code generation.  No dependency injection.  Just add it to your classpath and use it.  Extremely simple unit testing!
		<li>Tiny - ~1MB
		<li>Exhaustively tested
	</ul>
	
	<h5 class='toc'>Prerequisites</h5>
	
	<p>
		We've strived to keep prerequisites to an absolute minimum.
	</p>
	<ul class='spaced-list'>
		<li>The serializers and parsers require nothing more than Java 6+.
		<li>The RDF serializers and parsers require Apache Jena 2.5.1+.
		<li>The REST server API requires any Servlet 3.1.0+ container.
		<li>The REST client API requires Apache HttpClient 4.5+.
		<li>The REST microservice API uses Eclipse Jetty 9.4.3.
	</ul>	
		
	<h5 class='toc'>Components</h5>
	<p>
		The library consists of 4 components/jars and a single uber-jar that contains everything. 
	</p>
	<img src='images/Components.png'>

	<h5 class='toc'>Juneau Core</h5>
	<p>
		Core library includes easy-to-use and customizable serializers and parsers.  The examples here provide a small taste of what's possible. 
	</p>
	<p>
		The default serializers can often be used to serialize POJOs in a single line of code:
	</p>
	<p class='bcode'>
	<jc>// A simple bean</jc>
	<jk>public class</jk> Person {
		<jk>public</jk> String name = <js>"John Smith"</js>;
		<jk>public int</jk> age = 21;
	}
	
	<jc>// Serialize a bean to JSON, XML, or HTML</jc>
	Person p = <jk>new</jk> Person();
	
	<jc>// Produces:
	// "{name:'John Smith',age:21}"</jc>
	String laxJson = JsonSerializer.<jsf>DEFAULT_LAX</jsf>.serialize(p);
	
	<jc>// Produces:
	// "{"name":"John Smith","age":21}"</jc>
	String strictJson = JsonSerializer.<jsf>DEFAULT</jsf>.serialize(p);
	
	<jc>// Produces:
	// &lt;object&gt;
	//   &lt;name&gt;John Smith&lt;/name&gt;
	//   &lt;age&gt;21&lt;/age&gt;
	// &lt;/object&gt;</jc>
	String xml = XmlSerializer.<jsf>DEFAULT_SIMPLE</jsf>.serialize(p);
	
	<jc>// Produces:
	// &lt;table&gt;
	//   &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;John Smith&lt;/td&gt;&lt;/tr&gt;
	//   &lt;tr&gt;&lt;td&gt;age&lt;/td&gt;&lt;td&gt;21&lt;/td&gt;&lt;/tr&gt;
	// &lt;/table&gt;</jc>
	String html = HtmlSerializer.<jsf>DEFAULT</jsf>.serialize(p);
	
	<jc>// Same as Html, but wraps it in HTML and BODY elements with page title/description/links:</jc>
	String htmlDoc = HtmlDocSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// name='John+Smith'&amp;age=21</jc>
	String urlEncoding = UrlEncodingSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// (name='John Smith',age=21)</jc>
	String uon = UonSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// 82 A4 name AA 4A John Smith 68 A3 age 15</jc>
	<jk>byte</jk>[] messagePack = MsgPackSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// &lt;rdf:RDF
	//  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	//  xmlns:jp="http://www.apache.org/juneaubp/"
	//  xmlns:j="http://www.apache.org/juneau/"&gt;
	// 	&lt;rdf:Description&gt;
	// 		&lt;jp:name&gt;John Smith&lt;/jp:name&gt;
	// 		&lt;jp:age&gt;21&lt;/jp:age&gt;
	// 	&lt;/rdf:Description&gt;
	// &lt;/rdf:RDF&gt;</jc>
	String rdfXml = RdfSerializer.<jsf>DEFAULT_XMLABBREV</jsf>.serialize(p);
	
	<jc>// Produces:
	// @prefix jp:      &lt;http://www.apache.org/juneaubp/&gt; .
	// @prefix j:       &lt;http://www.apache.org/juneau/&gt; .
	//	[]    jp:age  "21" ;
	//	      jp:name "John Smith" .</jc>
	String rdfN3 = RdfSerializer.<jsf>DEFAULT_N3</jsf>.serialize(p);

	<jc>// Produces:
	// _:A3bf53c85X3aX157cf407e2dX3aXX2dX7ffd &lt;http://www.apache.org/juneaubp/name&gt; "John Smith" .
	// _:A3bf53c85X3aX157cf407e2dX3aXX2dX7ffd &lt;http://www.apache.org/juneaubp/age&gt; "21" .</jc>
	String rdfNTriple = RdfSerializer.<jsf>DEFAULT_NTRIPLE</jsf>.serialize(p);
	</p>
	<p>
		Parsing back into POJOs is equally simple for any of the supported languages shown above (JSON shown here):
	</p>
	<p class='bcode'>
	<jc>// Use one of the predefined parsers.</jc>
	ReaderParser parser = JsonParser.<jsf>DEFAULT</jsf>;
	
	<jc>// Parse a JSON object (creates a generic ObjectMap).</jc>
	String json = <js>"{name:'John Smith',age:21}"</js>;
	Map m1 = parser.parse(json, Map.<jk>class</jk>);
	
	<jc>// Parse a JSON string.</jc>
	json = <js>"'foobar'"</js>;
	String s2 = parser.parse(json, String.<jk>class</jk>);
	
	<jc>// Parse a JSON number as a Long or Float.</jc>
	json = <js>"123"</js>;
	Long l3 = parser.parse(json, Long.<jk>class</jk>);
	Float f3 = parser.parse(json, Float.<jk>class</jk>);
	
	<jc>// Parse a JSON object as a bean.</jc>
	json = <js>"{name:'John Smith',age:21}"</js>;
	Person p4 = parser.parse(json, Person.<jk>class</jk>);
	
	<jc>// Parse a JSON object as a HashMap&lt;String,Person&gt;.</jc>
	json = <js>"{a:{name:'John Smith',age:21},b:{name:'Joe Smith',age:42}}"</js>;
	Map&lt;String,Person&gt; m5 = parser.parse(json, HashMap.<jk>class</jk>, String.<jk>class</jk>, Person.<jk>class</jk>);
	
	<jc>// Parse a JSON object as a HashMap&lt;String,LinkedList&lt;Person&gt;&gt;.</jc>
	json = <js>"{a:[{name:'John Smith',age:21},{name:'Joe Smith',age:42}]}"</js>;
	Map&lt;String,List&lt;Person&gt;&gt; m6 = parser.parse(json, HashMap.<jk>class</jk>, String.<jk>class</jk>, LinkedList.<jk>class</jk>, Person.<jk>class</jk>);

	<jc>// Parse a JSON array of integers as a Collection of Integers or int[] array.</jc>
	json = <js>"[1,2,3]"</js>;
	List&lt;Integer&gt; l7 = parser.parse(json, LinkedList.<jk>class</jk>, Integer.<jk>class</jk>);
	<jk>int</jk>[] i7 = parser.parse(json, <jk>int</jk>[].<jk>class</jk>);
	
	<jc>// Parse arbitrary input into ObjectMap or ObjectList objects 
	// (similar to JSONObject/JSONArray but generalized for all languages).</jc>
	json = <js>"{name:'John Smith',age:21}"</js>;
	ObjectMap m8a = parser.parse(json, ObjectMap.<jk>class</jk>);
	<jk>int</jk> age = m8a.getInt(<js>"age"</js>);
	ObjectMap m8b = (ObjectMap)parser.parse(json, Object.<jk>class</jk>);  <jc>// Equivalent.</jc>
	
	json = <js>"[1,true,null]"</js>;
	ObjectList l9a = parser.parse(json, ObjectList.<jk>class</jk>);  
	<jk>boolean</jk> b = l9a.getBoolean(1);
	ObjectList l9b = (ObjectList)parser.parse(json, Object.<jk>class</jk>);  <jc>// Equivalent.</jc>  
	</p>
	<h5 class='toc'>Features</h5>
	<ul class='spaced-list'>
		<li>Serializers can send output directly to Writers, OutputStreams, Files, Strings, or byte arrays.
		<li>Parsers can receive input directly from Readers, InputStreams, Files, Strings, or byte arrays.
		<li>Parsers can reconstruct arbitrarily complex data structures consisting of maps, collections, beans, and other POJOs.
		<li>Serializers and parsers do not use intermediate DOMs!  POJOs are serialized directly to streams and parsed back directly to POJOs, making them extremely efficient and fast.
	</ul>
	<br><hr>
	<p>
		Serializers and parsers are builder-based.  Build from scratch or clone existing instances.  Lots of configuration options available for all the languages.
	</p>
	<p class='bcode'>
	<jc>// Create a serializer from scratch using a builder</jc>
	JsonSerializer serializer = <jk>new</jk> JsonSerializerBuilder()
		.simple()  <jc>// Simple mode</jc>
		.sq()  <jc>// Use single quotes</jc>
		.pojoSwaps(   <jc>// Swap unserializable classes with surrogate POJOs</jc>
			IteratorSwap.<jk>class</jk>, <jc>// Iterators swapped with lists</jc>
			ByteArrayBase64Swap.<jk>class</jk>, <jc>// byte[] swapped with base-64 encoded strings</jc>
			CalendarSwap.ISO8601DT.<jk>class</jk> <jc>// Calendars swapped with ISO8601-compliant strings</jc>
		)
		.beanFilters(MyBeanFilter.<jk>class</jk>)  <jc>// Control how bean properties are handled</jc>
		.timeZone(TimeZone.<jsf>GMT</jsf>)  <jc>// For serializing Calendars</jc>
		.locale(Locale.<jsf>JAPAN</jsf>)  <jc>// For timezone-specific serialization</jc>
		.sortCollections(<jk>true</jk>)  <jc>// For locale-specific serialization</jc>
		.sortProperties(<jk>true</jk>)  <jc>// Various behavior settings</jc>
		.trimNullProperties(<jk>true</jk>)
		.trimStrings(<jk>true</jk>)
		.methodVisibility(<jsf>PROTECTED</jsf>)  <jc>// Control which fields/methods are serialized</jc>
		.beanDictionary(  <jc>// Adds type variables for resolution during parsing</jc>
			MyBeanA.<jk>class</jk>, 
			MyBeanB.<jk>class</jk>
		)
		.debug(<jk>true</jk>)  <jc>// Add debug output</jc>
		.build();
	   
	<jc>// Clone an existing serializer and modify it to use single-quotes</jc>
	JsonSerializer serializer = JsonSerializer.<jsf>DEFAULT</jsf>.builder()
		.sq()
		.build();	
	</p>
	<br><br><hr>
	<p>
		Many POJOs such as primitives, beans, collections, arrays, and classes with various known constructors and methods are serializable out-of-the-box.  
		For other objects, "transforms" allow you to perform various mutations on them before serialization and after parsing.  
	</p>
	<ul class='spaced-list'>
		<li>Transforms
			<ul>
				<li>Bean filters - Control how bean properties are handled (naming conventions, ordering, visibility,...).
				<li>POJO swaps - Replace non-serializable POJOs with serializable equivalents.
					<br>Predefined swaps provided for common cases: <code>ByteArrayBase64Swap</code>, 50+ variants of Calendar/Date swaps, <code>Enumeration/Iterator</code> swaps.
			</ul>
		<li>Annotations 
			<br>Various annotations available for your POJO classes that are recognized by ALL serializers and parsers:  
			<br><ja>@Bean</ja>, <ja>@Pojo</ja>, <ja>@BeanIgnore</ja>, <ja>@BeanParam</ja>, <ja>@BeanProperty</ja>, <ja>@NameProperty</ja>, <ja>@ParentProperty</ja>
			<br>
			<br>Annotations also provided for language-specific behaviors:
			<br><ja>@Json</ja>, <ja>@Html</ja>, <ja>@Xml</ja>, <ja>@UrlEncoding</ja>
			<br>
			<br>All annotations have programmatic equivalents when you don't have access to POJO source.
			
		<li>Swap methods
			<br>By default, various instance and static methods and constructors are automatically detected and supported:
			<br><code>valueOf(String)</code>, <code>parse(String)</code>, <code>parseString(String)</code>, <code>forName(String)</code>, <code>forString(String)</code>, 
				<code>fromString(String)</code>, <code>T(String)</code>, <code>Object swap(BeanSession)</code>, <code>T unswap(BeanSession, T.class)</code>
	</ul>

	<h5 class='topic'>Additional Information</h5>
	<ul class='doctree'>
		<li class='link'>See <a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#Core.PojoCategories'>POJO Categories</a> for a definition of supported POJOs.
	</ul>

	<br><hr>
	<p>
		UON (URL-Encoded Object Notation) allows JSON-like data structures (OBJECT, ARRAY, NUMBER, BOOLEAN, STRING, NULL) in HTTP constructs (query parameters, form parameters,
		headers, URL parts) without violating RFC2396.
		This allows POJOs to be converted directly into HTTP constructs.
	</p>
	<p class='bcode'>
	(
		id=1, 
		name=<js>'John+Smith'</js>, 
		uri=<js>http://sample/addressBook/person/1</js>, 
		addressBookUri=<js>http://sample/addressBook</js>,
		birthDate=<js>1946-08-12T00:00:00Z</js>,
		addresses=@(
			(
				uri=<js>http://sample/addressBook/address/1</js>, 
				personUri=<js>http://sample/addressBook/person/1</js>, 
				id=<js>1</js>, 
				street=<js>'100+Main+Street'</js>, 
				city=<js>Anywhereville</js>, 
				state=<js>NY</js>, 
				zip=<js>12345</js>, 
				isCurrent=<jk>true</jk>
			)
		)
	)
	</p>
	<br><br><hr>
	<p>
		Lots of shortcuts are provided throughout the API to simplify tasks, and the APIs are often useful for debugging and logging purposes as well...
	</p>
	<p class='bcode'>
	<jc>// Create JSON strings from scratch using fluent-style code.</jc>
	String jsonObject = <jk>new</jk> ObjectMap().append(<js>"foo"</js>,<js>"bar"</js>).toString(); 
	String jsonArray = <jk>new</jk> ObjectList().append(<js>"foo"</js>).append(123).append(<jk>null</jk>).toString(); 
	
	<jc>// Create maps and beans directly from JSON.</jc>
	Map&lt;String,Object&gt; myMap = <jk>new</jk> ObjectMap(<js>"{foo:'bar'}"</js>); 
	List&lt;Object&gt; myList = <jk>new</jk> ObjectList(<js>"['foo',123,null]"</js>); 

	<jc>// Load a POJO from a JSON file.</jc>
	MyPojo myPojo = JsonParser.<jsf>DEFAULT</jsf>.parse(<jk>new</jk> File(<js>"myPojo.json"</js>));

	<jc>// Serialize POJOs and ignore exceptions (great for logging)</jc>
	String json = JsonSerializer.<jsf>DEFAULT_LAX</jsf>.toString(myPojo);
	
	<jc>// Dump a POJO to the console.</jc>
	JsonSerializer.<jsf>DEFAULT_LAX</jsf>.println(myPojo);
	
	<jc>// Delayed serialization.</jc>
	<jc>// (e.g. don't serialize an object if it's not going to be logged).</jc>
	logger.log(<jsf>FINE</jsf>, <js>"My POJO was: {0}"</js>, <jk>new</jk> StringObject(myPojo));
	logger.log(<jsf>FINE</jsf>, <js>"My POJO in XML was: {0}"</js>, <jk>new</jk> StringObject(XmlSerializer.<jsf>DEFAULT</jsf>, myPojo));
	
	String message = <jk>new</jk> StringMessage(<js>"My POJO in {0}: {1}"</js>, <js>"JSON"</js>, <jk>new</jk> StringObject(myPojo)).toString();
	
	<jc>// Create a 'REST-like' wrapper around a POJO.</jc>
	<jc>// Allows you to manipulate POJO trees using URIs and GET/PUT/POST/DELETE commands.</jc>
	PojoRest pojoRest = <jk>new</jk> PojoRest(myPojo);
	pojoRest.get(String.<jk>class</jk>, <js>"addressBook/0/name"</js>);
	pojoRest.put(<js>"addressBook/0/name"</js>, <js>"John Smith"</js>);
	</p>
	<br><br><hr>
	<p>
		<code>SerializerGroup</code> and <code>ParserGroup</code> classes allow serializers and parsers 
		to be retrieved by W3C-compliant HTTP <code>Accept</code> and <code>Content-Type</code> values:
	</p>
	<p class='bcode'>
	<jc>// Construct a new serializer group with configuration parameters that get applied to all serializers.</jc>
	SerializerGroup sg = <jk>new</jk> SerializerGroupBuilder()
		.append(JsonSerializer.<jk>class</jk>, UrlEncodingSerializer.<jk>class</jk>);
		.ws()   <jc>// or .setUseWhitespace(true)</jc>
		.pojoSwaps(CalendarSwap.ISO8601DT.<jk>class</jk>)
		.build();

	<jc>// Find the appropriate serializer by Accept type and serialize our POJO to the specified writer.</jc>
	<jc>// Fully RFC2616 compliant.</jc>
	sg.getSerializer(<js>"text/invalid, text/json;q=0.8, text/*;q:0.6, *\/*;q=0.0"</js>)
		.serialize(myPersonObject, myWriter);
		
	<jc>// Construct a new parser group with configuration parameters that get applied to all parsers.</jc>
	ParserGroup pg = <jk>new</jk> ParserGroupBuilder()
		.append(JsonParser.<jk>class</jk>, UrlEncodingParser.<jk>class</jk>);
 		.pojoSwaps(CalendarSwap.ISO8601DT.<jk>class</jk>)
 		.build();

	Person p = pg.getParser(<js>"text/json"</js>).parse(myReader, Person.<jk>class</jk>);
	</p>
	
	<h5 class='topic'>Additional Information</h5>
	<ul class='doctree'>
		<li class='link'><a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#Core'>Juneau Core (org.apache.juneau)</a>
	</ul>

	<br><hr>

	<h5 class='toc'>DTO libraries</h5>
	<p>
		Data Transfer Object libraries are provided for a variety of languages that allow you to serialize commonly-used
		documents.  
	</p>
	<p>	
		HTML5 documents and fragments can be constructed using the HTML5 DTOs and HTML or XML serializers:
	</p>
	<p class='bcode'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
		
	Object myform =
		<jsm>form</jsm>().action(<js>"/submit"</js>).method(<js>"POST"</js>)
		.children(
			<js>"Position (1-10000): "</js>, <jsm>input</jsm>(<js>"number"</js>).name(<js>"pos"</js>).value(1), <jsm>br</jsm>(),
			<js>"Limit (1-10000): "</js>, <jsm>input</jsm>(<js>"number"</js>).name(<js>"limit"</js>).value(100), <jsm>br</jsm>(),
			<jsm>button</jsm>(<js>"submit"</js>, <js>"Submit"</js>),
			<jsm>button</jsm>(<js>"reset"</js>, <js>"Reset"</js>)
		); 	

	String html = HtmlSerializer.<jsf>DEFAULT</jsf>.serialize(myform);
	</p>
	<p class='bcode'><xt>
		&lt;form <xa>action</xa>=<xs>'/submit'</xs> <xa>method</xa>=<xs>'POST'</xs>&gt;
			<xv>Position (1-10000):</xv> &lt;input <xa>name</xa>=<xs>'pos'</xs> <xa>type</xa>=<xs>'number'</xs> <xa>value</xa>=<xs>'1'</xs>/&gt;&lt;br/&gt;
			<xv>Limit (1-10000):</xv> &lt;input <xa>name</xa>=<xs>'pos'</xs> <xa>type</xa>=<xs>'number'</xs> <xa>value</xa>=<xs>'100'</xs>/&gt;&lt;br/&gt;
			&lt;button <xa>type</xa>=<xs>'submit'</xs>&gt;<xv>Submit</xv>&lt;/button&gt;
			&lt;button <xa>type</xa>=<xs>'reset'</xs>&gt;<xv>Reset</xv>&lt;/button&gt;			 
		&lt;/form&gt;
	</xt></p>
	<p>	
		ATOM feeds can be constructed using the ATOM DTOs and XML serializer:
	</p>
	<p class='bcode'>
	<jk>import static</jk> org.apache.juneau.dto.atom.AtomBuilder.*;
	
	Feed feed = 
		<jsm>feed</jsm>(<js>"tag:juneau.apache.org"</js>, <js>"Juneau ATOM specification"</js>, <js>"2016-01-02T03:04:05Z"</js>)
		.subtitle(<jsm>text</jsm>(<js>"html"</js>).text(<js>"Describes &lt;em&gt;stuff&lt;/em&gt; about Juneau"</js>))
		.links(
			<jsm>link</jsm>(<js>"alternate"</js>, <js>"text/html"</js>, <js>"http://juneau.apache.org/"</js>).hreflang(<js>"en"</js>),
			<jsm>link</jsm>(<js>"self"</js>, <js>"application/atom+xml"</js>, <js>"http://juneau.apache.org/feed.atom"</js>)
		)
		.rights(<js>"Copyright (c) 2016, Apache Foundation"</js>)
		.entries(
			<jsm>entry</jsm>(<js>"tag:juneau.sample.com,2013:1.2345"</js>, <js>"Juneau ATOM specification snapshot"</js>, <js>"2016-01-02T03:04:05Z"</js>)
			.published(<js>"2016-01-02T03:04:05Z"</js>)
			.content(
				<jsm>content</jsm>(<js>"xhtml"</js>)
				.lang(<js>"en"</js>)
				.base(<js>"http://www.apache.org/"</js>)
				.text(<js>"&lt;div&gt;&lt;p&gt;&lt;i&gt;[Update: Juneau supports ATOM.]&lt;/i&gt;&lt;/p&gt;&lt;/div&gt;"</js>)
			)
		);
	
	<jc>// Serialize to ATOM/XML</jc>
	String atomXml = XmlSerializer.<jsf>DEFAULT</jsf>.serialize(feed);
		</p>
		<p class='bcode'>
	<xt>&lt;feed&gt;</xt>
		<xt>&lt;id&gt;</xt>
			tag:juneau.apache.org
		<xt>&lt;/id&gt;</xt>
		<xt>&lt;link</xt> <xa>href</xa>=<xs>'http://juneau.apache.org/'</xs> <xa>rel</xa>=<xs>'alternate'</xs> <xa>type</xa>=<xs>'text/html'</xs> <xa>hreflang</xa>=<xs>'en'</xs>/<xt>&gt;</xt>
		<xt>&lt;link</xt> <xa>href</xa>=<xs>'http://juneau.apache.org/feed.atom'</xs> <xa>rel</xa>=<xs>'self'</xs> <xa>type</xa>=<xs>'application/atom+xml'</xs>/<xt>&gt;</xt>
		<xt>&lt;rights&gt;</xt>
			Copyright (c) 2016, Apache Foundation
		<xt>&lt;/rights&gt;</xt>
		<xt>&lt;title</xt> <xa>type</xa>=<xs>'text'</xs>&gt;</xt>
			Juneau ATOM specification
		<xt>&lt;/title&gt;</xt>
		<xt>&lt;updated&gt;</xt>2016-01-02T03:04:05Z<xt>&lt;/updated&gt;</xt>
		<xt>&lt;subtitle</xt> <xa>type</xa>=<xs>'html'</xs><xt>&gt;</xt>
			Describes &lt;em&gt;stuff&lt;/em&gt; about Juneau
		<xt>&lt;/subtitle&gt;</xt>
		<xt>&lt;entry&gt;</xt>
			<xt>&lt;id&gt;</xt>
				tag:juneau.apache.org
			<xt>&lt;/id&gt;</xt>
			<xt>&lt;title&gt;</xt>
				Juneau ATOM specification snapshot
			<xt>&lt;/title&gt;</xt>
			<xt>&lt;updated&gt;</xt>2016-01-02T03:04:05Z<xt>&lt;/updated&gt;</xt>
			<xt>&lt;content</xt> <xa>base</xa>=<xs>'http://www.apache.org/'</xs> <xa>lang</xa>=<xs>'en'</xs> <xa>type</xa>=<xs>'xhtml'</xs><xt>&gt;</xt>
				<xt>&lt;div</xt> <xa>xmlns</xa>=<xs>"http://www.w3.org/1999/xhtml"</xs><xt>&gt;&lt;p&gt;&lt;i&gt;</xt>[Update: Juneau supports ATOM.]<xt>&lt;/i&gt;&lt;/p&gt;&lt;/div&gt;</xt>
			<xt>&lt;/content&gt;</xt>
			<xt>&lt;published&gt;</xt>2016-01-02T03:04:05Z<xt>&lt;/published&gt;</xt>
		<xt>&lt;/entry&gt;</xt>
	<xt>&lt;/feed&gt;</xt>		
	</p>
	<p>	
		Swagger documents can be constructed using the Swagger DTOs and JSON serializer:
	</p>
	<p class='bcode'>
	<jk>import static</jk> org.apache.juneau.dto.swagger.SwaggerBuilder.*;

	Swagger swagger = <jsm>swagger</jsm>()
		.swagger(<js>"2.0"</js>)
		.info(
			<jsm>info</jsm>(<js>"Swagger Petstore"</js>, <js>"1.0.0"</js>)
				.description(<js>"This is a sample server Petstore server."</js>)
				.termsOfService(<js>"http://swagger.io/terms/"</js>)
				.contact(
					<jsm>contact</jsm>().email(<js>"apiteam@swagger.io"</js>)
				)
				.license(
					<jsm>license</jsm>(<js>"Apache 2.0"</js>).url(<js>"http://www.apache.org/licenses/LICENSE-2.0.html"</js>)
				)
		)
		.path(<js>"/pet"</js>, <js>"post"</js>,
			<jsm>operation</jsm>()
				.tags(<js>"pet"</js>)
				.summary(<js>"Add a new pet to the store"</js>)
				.description(<js>""</js>)
				.operationId(<js>"addPet"</js>)
				.consumes(MediaType.<jsf>JSON</jsf>, MediaType.<jsf>XML</jsf>)
				.produces(MediaType.<jsf>JSON</jsf>, MediaType.<jsf>XML</jsf>)
				.parameters(
					<jsm>parameterInfo</jsm>(<js>"body"</js>, <js>"body"</js>)
						.description(<js>"Pet object that needs to be added to the store"</js>)
						.required(<jk>true</jk>)
				)
				.response(405, <jsm>responseInfo</jsm>(<js>"Invalid input"</js>))
		);

	<jc>// Serialize to Swagger/JSON</jc>
	String swaggerJson = JsonSerializer.<jsf>DEFAULT_READABLE</jsf>.serialize(swagger);
	</p>
	<p class='bcode'>
	{
		<jf>"swagger"</jf>: <js>"2.0"</js>,
		<jf>"info"</jf>: {
			<jf>"title"</jf>: <js>"Swagger Petstore"</js>,
			<jf>"description"</jf>: <js>"This is a sample server Petstore server."</js>,
			<jf>"version"</jf>: <js>"1.0.0"</js>,
			<jf>"termsOfService"</jf>: <js>"http://swagger.io/terms/"</js>,
			<jf>"contact"</jf>: {
				<jf>"email"</jf>: <js>"apiteam@swagger.io"</js>
			},
			<jf>"license"</jf>: {
				<jf>"name"</jf>: <js>"Apache 2.0"</js>,
				<jf>"url"</jf>: <js>"http://www.apache.org/licenses/LICENSE-2.0.html"</js>
			}
		},
		<jf>"paths"</jf>: {
			<jf>"/pet"</jf>: {
				<jf>"post"</jf>: {
					<jf>"tags"</jf>: [
						<js>"pet"</js>
					],
					<jf>"summary"</jf>: <js>"Add a new pet to the store"</js>,
					<jf>"description"</jf>: <js>""</js>,
					<jf>"operationId"</jf>: <js>"addPet"</js>,
					<jf>"consumes"</jf>: [
						<js>"application/json"</js>,
						<js>"text/xml"</js>
					],
					<jf>"produces"</jf>: [
						<js>"application/json"</js>,
						<js>"text/xml"</js>
					],
					<jf>"parameters"</jf>: [
						{
							<jf>"in"</jf>: <js>"body"</js>,
							<jf>"name"</jf>: <js>"body"</js>,
							<jf>"description"</jf>: <js>"Pet object that needs to be added to the store"</js>,
							<jf>"required"</jf>: <jk>true</jk>
						}
					],
					<jf>"responses"</jf>: {
						<jf>"405"</jf>: {
							<jf>"description"</jf>: <js>"Invalid input"</js>
						}
					}
				}
			}
		},
	}		
	</p>
	<p>
		Note that these DTOs can also be serialized to any of the other supported languages such as JSON or MessagePack!
		And they can be parsed back into their original objects!
	</p>
	
	<h5 class='topic'>Additional Information</h5>
	<ul class='doctree'>
		<li class='link'><a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#DTOs'>Juneau Data Transfer Objects (org.apache.juneau.dto)</a>
	</ul>

	<br><hr>

	<h5 class='toc'>Juneau Server</h5>
	<p>
		The REST server API builds upon the <code>SerializerGroup</code> and <code>ParserGroup</code> classes 
		to provide annotated REST servlets that automatically negotiate the HTTP media types for you.
		<br>Developers simply work with requests, responses, headers, path variables, query parameters, and form data as POJOs.
		<br>Allows you to create sophisticated REST interfaces using tiny amounts of code.
	</p>
	<p>
		The end goal is to provide simple and flexible yet sophisticated REST interfaces that allow POJOs to be automatically represented as 
		different content types depending on whatever the particular need: 
	</p>
	<ul class='spaced-list'>
		<li>HTML for viewing POJOs in easy-to-read format in a browser.
		<li>JSON for interacting through Javascript.
		<li>XML for interacting with other applications.
		<li>RDF for interacting with triple stores.
		<li>URL-Encoding for interacting through HTML forms.
		<li>MessagePack for efficiently transmitting large amounts of data.
	</ul>
	<p>
		A simple example that supports all languages:
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/systemProperties"</js>,
		title=<js>"System properties resource"</js>
	)
	<jk>public class</jk> SystemPropertiesResource <jk>extends</jk> RestServletDefault {
	
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/"</js>)
		<jk>public</jk> Map getSystemProperties(<ja>@Query</ja>(<js>"sort"</js>) <jk>boolean</jk> sort) <jk>throws</jk> Throwable {
			<jk>if</jk> (sort)
				<jk>return new</jk> TreeMap(System.<jsm>getProperties</jsm>());
			<jk>return</jk> System.<jsm>getProperties</jsm>();
		}
	
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/{propertyName}"</js>)
		<jk>public</jk> String getSystemProperty(<ja>@Path</ja> String propertyName) <jk>throws</jk> Throwable {
			<jk>return</jk> System.<jsm>getProperty</jsm>(propertyName);
		}
	
		<ja>@RestMethod</ja>(name=<js>"PUT"</js>, path=<js>"/{propertyName}"</js>, guards=AdminGuard.<jk>class</jk>)
		<jk>public</jk> String setSystemProperty(<ja>@Path</ja> String propertyName, <ja>@Body</ja> String value) {
			System.<jsm>setProperty</jsm>(propertyName, value);
			<jk>return</jk> <js>"OK"</js>;
		}
	
		<ja>@RestMethod</ja>(name=<js>"POST"</js>, path=<js>"/"</js>, guards=AdminGuard.<jk>class</jk>)
		<jk>public</jk> String setSystemProperties(<ja>@Body</ja> java.util.Properties newProperties) {
			System.<jsm>setProperties</jsm>(newProperties);
			<jk>return</jk> <js>"OK"</js>;
		}
	
		<ja>@RestMethod</ja>(name=<js>"DELETE"</js>, path=<js>"/{propertyName}"</js>, guards=AdminGuard.<jk>class</jk>)
		<jk>public</jk> String deleteSystemProperty(<ja>@Path</ja> String propertyName) {
			System.<jsm>clearProperty</jsm>(propertyName);
			<jk>return</jk> <js>"OK"</js>;
		}
	}
	</p>
	<p>
		A more sophisticated example of the same resource using various features, including information
		for fully populating the Swagger documentation, guards for restricting access to particular
		methods, customizing supported content types and serialization options, adding g-zip compression, 
		and adding customized branding for the HTML views.
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/systemProperties"</js>,
		title=<js>"System properties resource"</js>,
		description=<js>"REST interface for performing CRUD operations on system properties."</js>,
		
		<jc>// Widget used for content-type pull-down menu.</jc>		
		widgets={
			ContentTypeMenuItem.<jk>class</jk>
		},
	
		<jc>// Links on the HTML rendition page.
		// "request:/..." URIs are relative to the request URI.
		// "servlet:/..." URIs are relative to the servlet URI.</jc>
		htmldoc=<ja>@HtmlDoc</ja>(
			
			<jc>// Custom navigation links.</jc>
			links={
				<js>"up: request:/.."</js>,
				<js>"options: servlet:/?method=OPTIONS"</js>,
				<js>"form: servlet:/formPage"</js>,
				<js>"$W{ContentTypeMenuItem}"</js>,
				<js>"source: $C{Source/gitHub}/org/apache/juneau/examples/rest/SystemPropertiesResource.java"</js>
			},
			
			<jc>// Custom page text in aside section.</jc>
			aside={
				<js>"&lt;div style='max-width:800px' class='text'&gt;"</js>,
				<js>"	&lt;p&gt;Shows standard GET/PUT/POST/DELETE operations and use of Swagger annotations.&lt;/p&gt;"</js>,
				<js>"&lt;/div&gt;"</js>
			},
				
			<jc>// Custom CSS styles applied to HTML view.</jc>
			style={
				<js>"aside {display:table-caption;}"</js>
			}
		),
				
		<jc>// Set serializer, parser, and REST context properties.</jc>
		properties={
			<ja>@Property</ja>(name=<jsf>SERIALIZER_quoteChar</jsf>, value=<js>"'"</js>)
		},
		
		<jc>// Add compression support.</jc>
		encoders=GzipEncoder.<jk>class</jk>,
		
		<jc>// Augment Swagger information.</jc>
		swagger=<ja>@ResourceSwagger</ja>(
			contact=<js>"{name:'John Smith',email:'john@smith.com'}"</js>,
			license=<js>"{name:'Apache 2.0',url:'http://www.apache.org/licenses/LICENSE-2.0.html'}"</js>,
			version=<js>"2.0"</js>,
			termsOfService=<js>"You're on your own."</js>,
			tags=<js>"[{name:'Java',description:'Java utility',externalDocs:{description:'Home page',url:'http://juneau.apache.org'}}]"</js>,
			externalDocs=<js>"{description:'Home page',url:'http://juneau.apache.org'}"</js>
		)
	)
	<jk>public class</jk> SystemPropertiesResource <jk>extends</jk> RestServlet {
	
		<ja>@RestMethod</ja>(
			name=<js>"GET"</js>, path=<js>"/"</js>,
			summary=<js>"Show all system properties"</js>,
			description=<js>"Returns all system properties defined in the JVM."</js>,
			
			<jc>// Augment Swagger information.</jc>
			swagger=<ja>@MethodSwagger</ja>(
				parameters={
					<ja>@Parameter</ja>(in=<js>"query"</js>, name=<js>"sort"</js>, description=<js>"Sort results alphabetically."</js>, _default=<js>"false"</js>)
				},
				responses={
					<ja>@Response</ja>(value=200, description=<js>"Returns a map of key/value pairs."</js>)
				}
			)
		)
		<jk>public</jk> Map getSystemProperties(<ja>@Query</ja>(<js>"sort"</js>) <jk>boolean</jk> sort) <jk>throws</jk> Throwable {
			<jk>if</jk> (sort)
				<jk>return new</jk> TreeMap(System.<jsm>getProperties</jsm>());
			<jk>return</jk> System.<jsm>getProperties</jsm>();
		}
	
		...
	}
	</p>
	
	<p>
		In HTML, our resource looks like this:
	</p>
	<img class='bordered' src='images/SystemPropertiesResource.png'>
	
	<p>
		When combined with the support for HTML5 beans, simple HTML forms can be constructed for easy input and output
		using nothing more than Java:
	</p>
	<p class='bcode'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
	
	<ja>@RestMethod</ja>(
		name=<js>"GET"</js>, path=<js>"/formPage"</js>,
		summary=<js>"Form entry page"</js>,
		description=<js>"A form post page for setting a single system property value."</js>,
		guards=AdminGuard.<jk>class</jk>
	)
	<jk>public</jk> Form getFormPage() {
		<jk>return</jk> <jsm>form</jsm>().method(<js>"POST"</js>).action(<js>"formPagePost"</js>).children(
			<jsm>h4</jsm>(<js>"Set system property"</js>),
			<js>"Name: "</js>, <jsm>input</jsm>(<js>"text"</js>).name(<js>"name"</js>), <jsm>br</jsm>(),
			<js>"Value: "</js>, <jsm>input</jsm>(<js>"text"</js>).name(<js>"value"</js>), <jsm>br</jsm>(), <jsm>br</jsm>(),
			<jsm>button</jsm>(<js>"submit","Click me!"</js>).style(<js>"float:right"</js>)
		);
	}

	<ja>@RestMethod</ja>(
		name=<js>"POST"</js>, path=<js>"/formPagePost"</js>, 
		description=<js>"Accepts a simple form post of a system property name/value pair."</js>,
		guards=AdminGuard.<jk>class</jk>
	)
	<jk>public</jk> Redirect formPagePost(<ja>@FormData</ja>(<js>"name"</js>) String name, <ja>@FormData</ja>(<js>"value"</js>) String value) {
		System.<jsm>setProperty</jsm>(name, value);
		<jk>return new</jk> Redirect(<js>"servlet:/"</js>);  <jc>// Redirect to the servlet top page.</jc>
	}
	</p>	
	<img class='bordered' src='images/SystemPropertiesForm.png'>
	<p>
		The REST API is built on top of Servlets, making them easy to deploy in any JEE environment.  
	</p>
	<p>
		REST Java methods can return any of the following objects:  
		<br>POJOs, <code>Readers</code>, <code>InputStreams</code>, <code>ZipFiles</code>, <code>Redirects</code>, <code>Streamables</code>, and <code>Writables</code>.
	</p>
	<p>
		Or add your own handlers for other types.  
	</p>
	<p>
		REST Java methods can be passed any of the following objects in any order:
	</p>
	<ul class='spaced-list'>
		<li>Low-level request/response objects:
			<br><code>HttpServletRequest</code>, <code>HttpServletResponse</code>, <code>RestRequest</code>, <code>RestResponse</code>.
		<li>Intermediate-level objects:  
			<br><code>RequestHeaders</code>, <code>RequestQuery</code>, <code>RequestFormData</code>, <code>RequestPathMatch</code>, <code>RequestBody</code>.
		<li>All RFC 2616 request header objects:  
			<br><code>Accept</code>, <code>AcceptLanguage</code>, <code>AcceptEncoding</code>...
		<li>Annotated parameters:  
			<br><ja>@Header</ja>, <ja>@Query</ja>, <ja>@FormData</ja>, <ja>@Path</ja>, <ja>@PathRemainder</ja>, <ja>@Body</ja>.  
		<li>Other objects:  
			<br><code>Locale</code>, <code>ResourceBundle</code>, <code>MessageBundle</code>, <code>InputStream</code>, <code>OutputStream</code>, <code>Reader</code>, <code>Writer</code>...
		<li>User-defined parameter types.
	</ul>
	<p>
		It's up to you how you want to define your REST methods. 
		As a general rule, there are 3 broad approaches typically used:
	</p>
	
	<h5 class='topic'>Methodology #1 - Annoted parameters</h5>	
	<p>
		This approach uses annotated parameters for retrieving input from the request.
	</p>
	<p class='bcode'>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/example1/{p1}/{p2}/{p3}/*"</js>)
	<jk>public</jk> String example1(
			<ja>@Method</ja> String method,                  <jc>// HTTP method.</jc>
			<ja>@Path</ja> String p1,                        <jc>// Path variables.</jc>
			<ja>@Path</ja> <jk>int</jk> p2,
			<ja>@Path</ja> UUID p3,
			<ja>@Query</ja>(<js>"q1"</js>) <jk>int</jk> q1,                    <jc>// Query parameters.</jc>
			<ja>@Query</ja>(<js>"q2"</js>) String q2,
			<ja>@Query</ja>(<js>"q3"</js>) UUID q3,
			<ja>@PathRemainder</ja> String remainder,        <jc>// Path remainder after pattern match.</jc>
			<ja>@Header</ja>(<js>"Accept-Language"</js>) String lang, <jc>// Headers.</jc>
			<ja>@Header</ja>(<js>"Accept"</js>) String accept,
			<ja>@Header</ja>(<js>"DNT"</js>) <jk>int</jk> doNotTrack
		) {

		<jc>// Send back a simple String response</jc>
		String output = String.<jsm>format</jsm>(
				<js>"method=%s, p1=%s, p2=%d, p3=%s, remainder=%s, q1=%d, q2=%s, q3=%s, lang=%s, accept=%s, dnt=%d"</js>,
				method, p1, p2, p3, remainder, q1, q2, q3, lang, accept, doNotTrack);
		<jk>return</jk> output;
	}
	</p>	
	
	<h5 class='topic'>Methodology #2 - Low-level request/response objects</h5>	
	<p>
		This approach uses low-level request/response objects to perform the same as above.
	</p>
	<p class='bcode'>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/example2/{p1}/{p2}/{p3}/*"</js>)
	<jk>public</jk> String example2(
			RestRequest req,          <jc>// A direct subclass of HttpServletRequest.</jc>
			RestResponse res          <jc>// A direct subclass of HttpServletResponse.</jc>
		) {
		
		<jc>// HTTP method.</jc>
		String method = req.getMethod();

		<jc>// Path variables.</jc>
		RequestPathMatch path = req.getPathMatch();
		String p1 = path.get(<js>"p1"</js>, String.<jk>class</jk>);
		<jk>int</jk> p2 = path.get(<js>"p2"</js>, <jk>int</jk>.<jk>class</jk>);
		UUID p3 = path.get(<js>"p3"</js>, UUID.<jk>class</jk>);

		<jc>// Query parameters.</jc>
		RequestQuery query = req.getQuery();
		<jk>int</jk> q1 = query.get(<js>"q1"</js>, 0, <jk>int</jk>.<jk>class</jk>);
		String q2 = query.get(<js>"q2"</js>, String.<jk>class</jk>);
		UUID q3 = query.get(<js>"q3"</js>, UUID.<jk>class</jk>);

		<jc>// Path remainder after pattern match.</jc>
		String remainder = req.getPathMatch().getRemainder();

		<jc>// Headers.</jc>
		String lang = req.getHeader(<js>"Accept-Language"</js>);
		String accept = req.getHeader(<js>"Accept"</js>);
		<jk>int</jk> doNotTrack = req.getHeaders().get(<js>"DNT"</js>, <jk>int</jk>.<jk>class</jk>);

		<jc>// Send back a simple String response</jc>
		String output = String.format(
				<js>"method=%s, p1=%s, p2=%d, p3=%s, remainder=%s, q1=%d, q2=%s, q3=%s, lang=%s, accept=%s, dnt=%d"</js>,
				method, p1, p2, p3, remainder, q1, q2, q3, lang, accept, doNotTrack);
		res.setOutput(output);  <jc>// Or use getWriter().</jc>
	}
	</p>	
	
	<h5 class='topic'>Methodology #3 - Intermediate-level API objects</h5>	
	<p>
		This approach is sort of the middle ground where you get access functional area APIs.
	</p>
	<p class='bcode'>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/example3/{p1}/{p2}/{p3}/*"</js>)
	<jk>public</jk> String example3(
			HttpMethod method,           <jc>// HTTP method.</jc>
			RequestPathMatch path,       <jc>// Path variables.</jc>
			RequestQuery query,          <jc>// Query parameters.</jc>
			RequestHeaders headers,      <jc>// Headers.</jc>
			AcceptLanguage lang,         <jc>// Specific header classes.</jc>
			Accept accept
		) {
		
		<jc>// Path variables.</jc>
		String p1 = path.get(<js>"p1"</js>, String.<jk>class</jk>);
		<jk>int</jk> p2 = path.get(<js>"p2"</js>, <jk>int</jk>.<jk>class</jk>);
		UUID p3 = path.get(<js>"p3"</js>, UUID.<jk>class</jk>);

		<jc>// Query parameters.</jc>
		<jk>int</jk> q1 = query.get(<js>"q1"</js>, 0, <jk>int</jk>.<jk>class</jk>);
		String q2 = query.get(<js>"q2"</js>, String.<jk>class</jk>);
		UUID q3 = query.get(<js>"q3"</js>, UUID.<jk>class</jk>);

		<jc>// Path remainder after pattern match.</jc>
		String remainder = path.getRemainder();

		<jc>// Headers.</jc>
		int doNotTrack = headers.get(<js>"DNT"</js>, <jk>int</jk>.<jk>class</jk>);

		<jc>// Send back a simple String response</jc>
		String output = String.format(
				<js>"method=%s, p1=%s, p2=%d, p3=%s, remainder=%s, q1=%d, q2=%s, q3=%s, lang=%s, accept=%s, dnt=%d"</js>,
				method, p1, p2, p3, remainder, q1, q2, q3, lang, accept, doNotTrack);
		res.setOutput(output);
	}
	</p>	
	<p>
		All three are completely equivalent.  It's up to your own coding preferences which methodology you use.
	</p>
	<br><hr>
	<p>
		Auto-generated OPTIONS pages are constructed from Swagger DTO beans, here shown serialized as HTML:
	</p>
	<img class='bordered' src='images/Swagger.png'>
	<p>
		Swagger documentation can be populated from annotations (as above), resource bundles, or Swagger JSON files.
	</p>
	<p>
		The page shown above is implemented on the RestServletDefault class in the method below which shows that it's doing nothing more than 
		serializing a Swagger bean which is constructed in the RestRequest object:
	</p>
	<p class='bcode'>
	<ja>@RestMethod</ja>(name=<js>"OPTIONS"</js>, path=<js>"/*"</js>)
	<jk>public</jk> Swagger getOptions(RestRequest req) {
		<jk>return</jk> req.getSwagger();
	}
	</p>
	<br><br><hr>
	<p>	
		Navigatable hierarchies of REST resources are easy to set up either programmatically or through annotations.
		<br>
		The following example is the <code>RootResources</code> class from the REST examples showing how to construct
		a grouping of resources using the <code>children()</code> annotation:
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/"</js>,
		title=<js>"Root resources"</js>,
		description=<js>"Example of a router resource page."</js>,
		widgets={
			PoweredByApache.<jk>class</jk>,
			ContentTypeMenuItem.<jk>class</jk>
		},
		htmldoc=<ja>@HtmlDoc</ja>(
			links={
				<js>"options: ?method=OPTIONS"</js>,
				<js>"$W{ContentTypeMenuItem}"</js>,
				<js>"source: $C{Source/gitHub}/org/apache/juneau/examples/rest/RootResources.java"</js>
			},
			aside={
				<js>"&lt;div style='max-width:400px' class='text'&gt;"</js>,
				<js>"	&lt;p&gt;This is an example of a 'router' page that serves as a jumping-off point to child resources.&lt;/p&gt;"</js>,
				<js>"	&lt;p&gt;Resources can be nested arbitrarily deep through router pages.&lt;/p&gt;"</js>,
				<js>"	&lt;p&gt;Note the options link provided that lets you see the generated swagger doc for this page.&lt;/p&gt;"</js>,
				<js>"	&lt;p&gt;Also note the source link on these pages to view the source code for the page.&lt;/p&gt;"</js>,
				<js>"	&lt;p&gt;All content on pages in the UI are serialized POJOs.  In this case, it's a serialized array of beans with 2 properties, 'name' and 'description'.&lt;/p&gt;"</js>,
				<js>"	&lt;p&gt;Other features (such as this aside) are added through annotations.&lt;/p&gt;"</js>,
				<js>"&lt;/div&gt;"</js>
			},
			footer=<js>"$W{PoweredByApache}"</js>
		),
		children={
			HelloWorldResource.<jk>class</jk>,
			PetStoreResource.<jk>class</jk>,
			SystemPropertiesResource.<jk>class</jk>,
			MethodExampleResource.<jk>class</jk>,
			RequestEchoResource.<jk>class</jk>,
			TempDirResource.<jk>class</jk>,
			AddressBookResource.<jk>class</jk>,
			SampleRemoteableServlet.<jk>class</jk>,
			PhotosResource.<jk>class</jk>,
			AtomFeedResource.<jk>class</jk>,
			JsonSchemaResource.<jk>class</jk>,
			SqlQueryResource.<jk>class</jk>,
			TumblrParserResource.<jk>class</jk>,
			CodeFormatterResource.<jk>class</jk>,
			UrlEncodedFormResource.<jk>class</jk>,
			ConfigResource.<jk>class</jk>,
			LogsResource.<jk>class</jk>,
			DockerRegistryResource.<jk>class</jk>,
			ShutdownResource.<jk>class</jk>
		}
	)
	<jk>public class</jk> RootResources <jk>extends</jk> RestServletGroupDefault { <jc>/* No code needed! */</jc> }
	</p>
	<p>
		The above resource when rendered in HTML shows how easy it is to discover and navigate to child resources using a browser:
	</p>
	<img class='bordered' src='images/Samples_RootResources.png'>
	<p>
		Resources can be nested arbitrarily deep.  
		The <ja>@RestResource</ja> and <ja>@RestMethod</ja> annotations can be applied to any classes, not just
		servlets.  The only requirement is that the top-level resource be a subclass of <code>RestServlet</code> as a hook into
		the servlet container.
	</p>
	
	<p>
		The <code>juneau-examples-rest</code> project includes various other examples that highlight some of the 
		capabilities of the REST servlet API.
		<br>
		For example, the <code>PetStoreResource</code> class shows some advanced features such as using POJO renders
		and converters, and HTML widgets.
	</p>
	<img class='bordered' src='images/PetStore.png'>
	
	<p>
		The beans being serialized are shown here:
	</p>
	<p class='bcode'>
	<jc>// Our bean class.</jc>
	<jk>public class</jk> Pet {

		<ja>@Html</ja>(link=<js>"servlet:/{id}"</js>)  <jc>// Creates a hyperlink in HTML view.</jc>
		<ja>@NameProperty</ja>                <jc>// Links the parent key to this bean.</jc>
		<jk>public int</jk> <jf>id</jf>;

		<jk>public</jk> String <jf>name</jf>;
		<jk>public</jk> Kind <jf>kind</jf>;

		<ja>@BeanProperty</ja>(format=<js>"$%.2f"</js>)  <jc>// Renders price in dollars.</jc>
		<jk>public float</jk> <jf>price</jf>;

		<ja>@BeanProperty</ja>(swap=DateSwap.<jsf>RFC2822D</jsf>.<jk>class</jk>)  <jc>// Renders dates in RFC2822 format.</jc>
		<jk>public</jk> Date <jf>birthDate</jf>;

		<jk>public int</jk> getAge() {
			Calendar c = <jk>new</jk> GregorianCalendar();
			c.setTime(<jf>birthDate</jf>);
			<jk>return new</jk> GregorianCalendar().get(Calendar.<jsf>YEAR</jsf>) - c.get(Calendar.<jsf>YEAR</jsf>);
		}
	}

	<ja>@Html</ja>(render=KindRender.<jk>class</jk>)  <jc>// Render as an icon in HTML.</jc>
	<jk>public static enum</jk> Kind {
		<jsf>CAT</jsf>, <jsf>DOG</jsf>, <jsf>BIRD</jsf>, <jsf>FISH</jsf>, <jsf>MOUSE</jsf>, <jsf>RABBIT</jsf>, <jsf>SNAKE</jsf>
	}

	<jk>public static class</jk> KindRender <jk>extends</jk> HtmlRender&lt;Kind&gt; {
		<ja>@Override</ja>
		<jk>public</jk> Object getContent(SerializerSession session, Kind value) {
			<jk>return new</jk> Img().src(<js>"servlet:/htdocs/"</js>+value.toString().toLowerCase()+<js>".png"</js>);
		}
		<ja>@Override</ja>
		<jk>public</jk> String getStyle(SerializerSession session, Kind value) {
			<jk>return</jk> <js>"background-color:#FDF2E9"</js>;
		}
	}
	</p>

	<p>
		The <code>QUERY</code> menu item shows the capabilities of Converters which are post-processors that
		work to filter POJOs after they've been returned by your Java method.
		<br>
		In this case, we're using the <code>Queryable</code> converter that allows us to perform search/view/sort/paging
		against collections of beans:
	</p>
	<img class='bordered' src='images/PetStore_Query.png'>

	<p>
		The drop-down menu items are implemented through "widgets" which allow you to embed arbitrary HTML, Javascript, 
		and CSS in the HTML view of the page.
	</p>
	<p class='bcode'>
	<ja>@RestMethod</ja>(
		name=<js>"GET"</js>,
		path=<js>"/"</js>,
		summary=<js>"The complete list of pets in the store"</js>,
		
		<jc>// Add 'query' and 'content-types' menu items.</jc>
		widgets={
			QueryMenuItem.<jk>class</jk>,
			ContentTypeMenuItem.<jk>class</jk>,
			StyleMenuItem.<jk>class</jk>
		},

		<jc>// Add our converter for POJO query support.</jc>
		converters=Queryable.<jk>class</jk>,
		
		<jc>// Add our menu items in the nav links.</jc>
		htmldoc=<ja>@HtmlDoc</ja>(
			links={
				<js>"up: request:/.."</js>,
				<js>"options: servlet:/?method=OPTIONS"</js>,
				<js>"$W{QueryMenuItem}"</js>,
				<js>"$W{ContentTypeMenuItem}"</js>,
				<js>"$W{StyleMenuItem}"</js>,
				<js>"source: $C{Source/gitHub}/org/apache/juneau/examples/rest/PetStoreResource.java"</js>
			}
		)
	)
	<jk>public</jk> Collection&lt;Pet&gt; getPets() {
	</p>
	
	<p>
		HTML views are highly customizable with abilities such as defining your own look-and-feel and even allowing
		you to define your own templates.
	</p>
	<p>
		For example, the PetStore page above rendered in one of the other predefined stylesheets:
	</p>	
	<img class='bordered' src='images/PetStore_light.png'>
	<br><hr>
	<p>
		Automatic error handling is provided for a variety of conditions: 
	</p>
	<ul>
		<li>Automatic 401 errors (Unauthorized) on failed guards.
		<li>Automatic 404 errors (Not Found) on unmatched path patterns.
		<li>Automatic 405 errors (Method Not Implemented) on unimplemented methods.
		<li>Automatic 406 errors (Not Acceptable) when no matching serializer was found to handle the <l>Accept</l> header.
		<li>Automatic 412 errors (Precondition Failed) when all matchers failed to match.
		<li>Automatic 415 errors (Unsupported Media Type) when no matching parser was found was found to handle the <l>Content-Type</l> header.
		<li>Automatic 500 errors on uncaught exceptions.
		<li>Throw your own runtime RestException with HTTP status and response object. 
	</ul>
	<p>
		Other features include: 
	</p> 
	<ul>
		<li>Extremely simple debuggability using nothing more than your browser.
		<li>Simplified localization support.
		<li>Configurability through external INI files.
		<li>Client-versioned responses (and other customizable heuristic matching APIs).
		<li>Define and use your own HTML stylesheets.
		<li>Optional JAX-RS integration.
		<li>Lots of up-to-date documentation and examples.
		<li>MUCH MORE!....
	</ul>

	<h5 class='topic'>Additional Information</h5>
	<ul class='doctree'>
		<li class='link'><a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#Server'>Juneau Server (org.apache.juneau.rest)</a>
	</ul>

	<br><hr>

	<h5 class='toc'>Juneau Client</h5>
	<p>
		The REST client API allows you to access REST interfaces using POJOs as well:
	</p>
	<p class='bcode'>
	<jc>// Create a reusable JSON client.</jc>
	RestClient client = <jk>new</jk> RestClientBuilder().build();
	
	<jc>// The address of the root resource.</jc>
	String url = <js>"http://localhost:10000/systemProperties"</js>;
	
	<jc>// Do a REST GET against a remote REST interface and convert
	// the response to an unstructured ObjectMap object.</jc>
	Map m1 = client.doGet(url).getResponse(TreeMap.<jk>class</jk>);
	
	<jc>// Add some new system properties.
	// Use XML as the transport medium.</jc>
	client = <jk>new</jk> RestClientBuilder(XmlSerializer.<jk>class</jk>, XmlParser.<jk>class</jk>).build();
	Properties p = <jk>new</jk> Properties();
	p.load(reader);
	<jk>int</jk> returnCode = client.doPost(url + <js>"/systemProperties"</js>, p).execute();
	</p>
	<p>
		The client API uses the same serializers and parsers (and subsequently their flexibilty and configurability) as the server side to marshall POJOs back and forth.
	</p>
	<br><hr>
	<p>
		The remote proxy interface API allows you to invoke server-side POJO methods on the client side using REST (i.e. RPC over REST):
	</p>
	<p class='bcode'>
 	<jc>// Get an interface proxy.</jc>
 	IAddressBook ab = restClient.getRemoteableProxy(IAddressBook.<jk>class</jk>);
	
	<jc>// Invoke a method on the server side and get the returned result.</jc>
	Person p = ab.createPerson(
		<jk>new</jk> Person(
			<js>"John Smith"</js>, 
			<js>"Aug 1, 1999"</js>,
			<jk>new</jk> Address(<js>"My street"</js>, <js>"My city"</js>, <js>"My state"</js>, 12345, <jk>true</jk>)
		)
	);
	</p>
	<p>
		There are two ways to expose remoteable proxies on the server side:
	</p>
	<ol>
		<li>Extending from <code>RemoteableServlet</code>.
		<li>Using a <code><ja>@RestMethod</ja>(name=<js>"PROXY"</js>)</code> annotation on a Java method.
	</ol>
	<p>
		The <code>RemoteableServlet</code> class is a simple specialized servlet with an abstract <code>getServiceMap()</code>
		method to define the server-side POJOs:
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/remote"</js>
	)
	<jk>public class</jk> SampleRemoteableServlet <jk>extends</jk> RemoteableServlet {
	
		<jc>// Our server-side POJO.</jc>
		AddressBook <jf>addressBook</jf> = <jk>new</jk> AddressBook();
	
		<ja>@Override</ja> <jc>/* RemoteableServlet */</jc>
		<jk>protected</jk> Map&lt;Class&lt;?&gt;,Object&gt; getServiceMap() <jk>throws</jk> Exception {
			Map&lt;Class&lt;?&gt;,Object&gt; m = <jk>new</jk> LinkedHashMap&lt;Class&lt;?&gt;,Object&gt;();
	
			<jc>// In this simplified example, we expose the same POJO service under two different interfaces.
			// One is IAddressBook which only exposes methods defined on that interface, and
			// the other is AddressBook itself which exposes all methods defined on the class itself (dangerous!).</jc>
			m.put(IAddressBook.<jk>class</jk>, <jf>addressBook</jf>);
			m.put(AddressBook.<jk>class</jk>, <jf>addressBook</jf>);
			<jk>return</jk> m;
		}
	}
	</p>
	<p>
		The <code><ja>@RestMethod</ja>(name=<js>"PROXY"</js>)</code> approach is easier if you only have a single interface you want to expose.  
		You simply define a Java method whose return type is an interface, and return the implementation of that interface:
	</p>
	<p class='bcode'>
	<jc>// Our exposed proxy object.</jc>
	<ja>@RestMethod</ja>(name=<js>"PROXY"</js>, path=<js>"/addressbookproxy/*"</js>)
	<jk>public</jk> IAddressBook getProxy() {
		<jk>return</jk> addressBook;
	}
	</p>
	<p>
		In either case, the proxy communications layer is pure REST.   
		Parameters passed in on the client side are serialized as an HTTP POST, parsed on the
		server side, and then passed to the invocation method.  The returned POJO is then marshalled back as an HTTP response.
	</p>
	<p>
		In most cases, you'll want to use JSON or MessagePack as your communications layer since these are the most efficent.
		Although remoteable proxies work perfectly well for any of the other supported languages.  For example, RPC over Turtle!
	</p>
	<p>
		The parameters and return types of the Java methods can be any of the supported serializable and parsable types in <a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#Core.PojoCategories'>POJO Categories</a>.
		This ends up being WAY more flexible than other proxy interfaces since Juneau can handle so may POJO types out-of-the-box.
		Most of the time you don't even need to modify your existing Java implementation code.
	</p>
	<p>
		The RemoteableServlet class itself shows how sophisticated REST interfaces can be built on the Juneau RestServlet
		API using very little code.  The RemoteableServlet class itself consists of only 53 lines of code, yet is
		a sophisticated discoverable and self-documenting REST interface.  And since the remote proxy API is built on top 
		of REST, it can be debugged using just a browser.
	</p>
	<br><hr>
	<p>
		Remoteable proxies can also be used to define interface proxies against 3rd-party REST interfaces.
		This is an extremely powerful feature that allows you to quickly define easy-to-use interfaces against virtually any REST interface.
	</p>
	<p>
		Similar in concept to remoteable services defined above, but in this case we simply define our interface with
		special annotations that tell us how to convert input and output to HTTP headers, query parameters, form post parameters, or request/response bodies.
	</p>
	<p class='bcode'>	
	<ja>@Remoteable</ja>
	<jk>public interface</jk> MyProxyInterface {
		
		<ja>@RemoteMethod</ja>(httpMethod=<js>"POST"</js>, path=<js>"/method"</js>)
		String doMethod(<ja>@Header</ja>(<js>"E-Tag"</js>) UUID etag, <ja>@Query</ja>(<js>"debug"</js>) <jk>boolean</jk> debug, <ja>@Body</ja> MyPojo pojo);
	}
	
	RestClient client = <jk>new</jk> RestClientBuilder().build();
	MyProxyInterface p = client.getRemoteableProxy(MyProxyInterface.<jk>class</jk>, <js>"http://hostname/some/rest/interface"</js>);
	String response = p.doMethod(UUID.<jsm>generate</jsm>(), <jk>true</jk>, <jk>new</jk> MyPojo());
	</p>

	<h5 class='topic'>Additional Information</h5>
	<ul class='doctree'>
		<li class='link'><a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#Client'>Juneau Client (org.apache.juneau.rest.client)</a>
	</ul>

	<br><hr>

	<h5 class='toc'>Config</h5>
	<p>
		The config file API allows you to interact with INI files using POJOs.  
		A sophisticated variable language is provided for referencing environment variables, system properties, other config file entries, and a host of other types.
	<p>
	<p class='bcode'>
	<cc>#--------------------------</cc>
	<cc># My section</cc>
	<cc>#--------------------------</cc>
	<cs>[MySection]</cs>
	
	<cc># An integer</cc>
	<ck>anInt</ck> = <cv>1</cv> 
	
	<cc># A boolean</cc>
	<ck>aBoolean</ck> = <cv>true</cv>
	
	<cc># An int array</cc>
	<ck>anIntArray</ck> = <cv>[1,2,3]</cv>
	
	<cc># A POJO that can be converted from a String</cc>
	<ck>aURL</ck> = <cv>http://foo </cv>
	
	<cc># A POJO that can be converted from JSON</cc>
	<ck>aBean</ck> = <cv>{foo:'bar',baz:123}</cv>
	
	<cc># A system property</cc>
	<ck>locale</ck> = <cv>$S{java.locale, en_US}</cv>
	
	<cc># An environment variable</cc>
	<ck>path</ck> = <cv>$E{PATH, unknown}</cv>
	
	<cc># A manifest file entry</cc>
	<ck>mainClass</ck> = <cv>$MF{Main-Class}</cv>
	
	<cc># Another value in this config file</cc>
	<ck>sameAsAnInt</ck> = <cv>$C{MySection/anInt}</cv>
	
	<cc># A command-line argument in the form "myarg=foo"</cc>
	<ck>myArg</ck> = <cv>$ARG{myarg}</cv>
	
	<cc># The first command-line argument</cc>
	<ck>firstArg</ck> = <cv>$ARG{0}</cv>

	<cc># Look for system property, or env var if that doesn't exist, or command-line arg if that doesn't exist.</cc>
	<ck>nested</ck> = <cv>$S{mySystemProperty,$E{MY_ENV_VAR,$ARG{0}}}</cv>

	<cc># A POJO with embedded variables</cc>
	<ck>aBean2</ck> = <cv>{foo:'$ARG{0}',baz:$C{MySection/anInt}}</cv>

		</p>
		<p>
			You're probably wondering "why INI files?"
			The beauty of these INI files is that they're easy to read and modify, yet sophisticated enough to allow you to
			store arbitrary-complex data structures and retrieve them as simple values or complex POJOs:
		</p>
		<p class='bcode'>
	<jc>// Load our config file</jc>
	ConfigFile f = <jk>new</jk> ConfigFileBuilder().build(<js>"MyIniFile.cfg"</js>);
	
	<jk>int</jk> anInt = cf.getInt(<js>"MySection/anInt"</js>); 
	<jk>boolean</jk> aBoolean = cf.getBoolean(<js>"MySection/aBoolean"</js>); 
	<jk>int</jk>[] anIntArray = cf.getObject(<jk>int</jk>[].<jk>class</jk>, <js>"MySection/anIntArray"</js>); 
	URL aURL = cf.getObject(URL.<jk>class</jk>, <js>"MySection/aURL"</js>); 
	MyBean aBean = cf.getObject(MyBean.<jk>class</jk>, <js>"MySection/aBean"</js>); 
	Locale locale = cf.getObject(Locale.<jk>class</jk>, <js>"MySection/locale"</js>); 
	String path = cf.getString(<js>"MySection/path"</js>); 
	String mainClass = cf.getString(<js>"MySection/mainClass"</js>); 
	<jk>int</jk> sameAsAnInt = cf.getInt(<js>"MySection/sameAsAnInt"</js>); 
	String myArg = cf.getString(<js>"MySection/myArg"</js>); 
	String firstArg = cf.getString(<js>"MySection/firstArg"</js>); 
	</p>
	<p>
		Values are LAX JSON (i.e. unquoted attributes, single quotes) except for top-level strings which are left unquoted.  
		Any parsable object types are supported as values (e.g. arrays, collections, beans, swappable objects, enums, etc...).
	</p>
	<p>
		One of the more powerful aspects of the REST servlets is that you can pull values directly from
		config files by using the <js>"$C"</js> variable in annotations.
		<br>For example, the HTML stylesheet for your REST servlet can be defined in a config file like so:
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/myResource"</js>,
		config=<js>"$S{my.config.file}"</js>,  <jc>// Path to config file (here pulled from a system property)</jc>
		stylesheet=<js>"$C{MyResourceSettings/myStylesheet}"</js>  <jc>// Stylesheet location pulled from config file.</jc>
	)
	<jk>public class</jk> MyResource <jk>extends</jk> RestServlet {
	</p>
	<p>
		Other features:
	</p>
	<ul>
		<li>A listener API that allows you to, for example, reinitialize your REST resource if the config file 
			changes, or listen for changes to particular sections or values.
		<li>Config files can be modified through the ConfigFile class (e.g. add/remove/modify sections and keys, add/remove comments and whitespace, etc...).
			<br>When using these APIs, you <b>DO NOT</b> lose formatting in your existing configuration file.
			All existing whitespace and comments are preserved for you!
		<li>Config file sections can be used to directly populate beans.
		<li>Config file sections can be accessed and manipulated through Java interface proxies.
	</ul>
	
	<h5 class='topic'>Additional Information</h5>
	<ul class='doctree'>
		<li class='link'><a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#Core.ConfigFile'>Configuration Files</a>
	</ul>

	<br><hr>

	<h5 class='toc'>Juneau Microservice</h5>
	<p>
		The microservice API combines all the features above with a built-in Jetty server to produce a lightweight 
		REST service packaged as three simple files:
	</p>
	<ul>
		<li>An executable jar file that starts up a REST interface in milliseconds.
		<li>A configurable <code>jetty.xml</code> file.
		<li>An external INI file that can be used to configure your REST resources on the fly.
	</ul>
	<p>
		The microservice API was originally designed for and particularly suited for use in Docker containers.
	</p>
	<p>
		REST microservices can also be started programmatically in existing code:
	</p>
	<p class='bcode'>
	RestMicroservice myRestService = <jk>new</jk> RestMicroservice()
		.setConfig(<js>"microservice.cfg"</js>, <jk>false</jk>)
		.setJettyXml(<js>"my-jetty.xml"</js>);
	myRestService.start();
	URI uri = myRestService.getURI();
	</p>
	<p>
		The provided microservice.cfg template file gives you a starting point for defining your microservice:
	</p>
	<p class='bcode'>
	<cc>#================================================================================
	# Basic configuration file for SaaS microservices
	# Subprojects can use this as a starting point.
	#================================================================================</cc>
	
	<cc>#================================================================================
	# REST settings
	#================================================================================</cc>
	<cs>[REST]</cs>
	
	<cc># The location of the jetty.xml file to use for configuring Jetty.</cc>
	<ck>jettyXml</ck> = <cv>jetty.xml</cv>

	<cc># Stylesheet to use for HTML views.
	# The default options are:
	#  - styles/juneau.css
	#  - styles/devops.css
	# Other stylesheets can be referenced relative to the servlet package or working
	# 	directory.</cc>
	<ck>stylesheet</ck> = <cv>styles/devops.css</cv>
	
	<cc># What to do when the config file is saved.
	# Possible values:
	# 	NOTHING - Don't do anything. 
	#	RESTART_SERVER - Restart the Jetty server.
	#	RESTART_SERVICE - Shutdown and exit with code '3'.</cc>
	<ck>saveConfigAction</ck> = <cv>RESTART_SERVER</cv>
	
	<cc>#================================================================================
	# Logger settings
	# See FileHandler Java class for details.
	#================================================================================</cc>
	<cs>[Logging]</cs>

	<cc># The directory where to create the log file.
	# Default is "."</cc>
	<ck>logDir</ck> = <cv>logs</cv>
	
	<cc># The name of the log file to create for the main logger.
	# The logDir and logFile make up the pattern that's passed to the FileHandler
	# constructor.
	# If value is not specified, then logging to a file will not be set up.</cc>
	<ck>logFile</ck> = <cv>microservice.%g.log</cv>
	
	<cc># Whether to append to the existing log file or create a new one.
	# Default is false.</cc>
	<ck>append</ck> = 
	
	<cc># The SimpleDateFormat format to use for dates.
	# Default is "yyyy.MM.dd hh:mm:ss".</cc>
	<ck>dateFormat</ck> = 
	
	<cc># The log message format.
	# The value can contain any of the following variables:
	# 	{date} - The date, formatted per dateFormat.
	#	{class} - The class name.
	#	{method} - The method name.
	#	{logger} - The logger name.
	#	{level} - The log level name.
	#	{msg} - The log message.
	#	{threadid} - The thread ID.
	#	{exception} - The localized exception message.
	# Default is "[{date} {level}] {msg}%n".</cc>
	<ck>format</ck> =
	
	<cc># The maximum log file size.
	# Suffixes available for numbers.
	# See ConfigFile.getInt(String,int) for details.
	# Default is 1M.</cc>
	<ck>limit</ck> = <cv>10M</cv>
	
	<cc># Max number of log files.
	# Default is 1.</cc>
	<ck>count</ck> = <cv>5</cv>
	
	<cc># Default log levels.
	# Keys are logger names.
	# Values are serialized Level POJOs.</cc>
	<ck>levels</ck> = <cv>{ org.apache.juneau:'INFO' }</cv>
	
	<cc># Only print unique stack traces once and then refer to them by a simple 8 character hash identifier.
	# Useful for preventing log files from filling up with duplicate stack traces.
	# Default is false.</cc>
	<ck>useStackTraceHashes</ck> = <cv>true</cv>
	
	<cc># The default level for the console logger.
	# Default is WARNING.</cc>
	<ck>consoleLevel</ck> = 
	
	<cc>#================================================================================
	# System properties
	#--------------------------------------------------------------------------------
	# These are arbitrary system properties that are set during startup.
	#================================================================================</cc>
	<cs>[SystemProperties]</cs>
	
	<cc># Configure Jetty for StdErrLog Logging</cc>
	<ck>org.eclipse.jetty.util.log.class</ck> = <cv>org.eclipse.jetty.util.log.StrErrLog</cv>
	
	<cc># Jetty logging level</cc>
	<ck>org.eclipse.jetty.LEVEL</ck> = <cv>WARN</cv>		
	</p>
	<p>
		Various predefined reusable REST resource classes are provided for accessing log files, viewing and editing the config file, etc...
		These allow you to quickly put together sophisticated REST microservices.
	</p>

	<h5 class='topic'>Additional Information</h5>
	<ul class='doctree'>
		<li class='link'><a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#Microservices'>Juneau Microservices (org.apache.juneau.microservice)</a>
	</ul>

	<br><hr>

	<h5 class='toc'>More information</h5>
	<p>
		<b>*ALL*</b> user documentation for this project is maintained in its <a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/index.html' target="_top">Javadocs</a>.
		If it's not in the Javadocs, it doesn't exist.
	</p>
	<p>
		The top-level <a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#overview.description' target="_top">Overview</a> document is a good
		starting point for developers wishing to get up-to-speed quickly.
	</p>
	<p align="center"><i><b>*** fi&#769;n ***</b></i></p>
</body>
</html>