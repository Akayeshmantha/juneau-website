<!DOCTYPE html>
<html>
<head>
<style>
	@import url("styles/juneau-code.css");
	@import url("styles/juneau-doc.css");
</style>
</head>
<body>
	<h5 class='toc'>About</h5>
	<ul class='spaced-list'>
		<li>A toolkit for marshalling POJOs to a variety of content types using a common framework.
		<li>A REST server API for creating Swagger-based self-documenting REST interfaces using POJOs.
		<li>A REST client API for interacting with REST interfaces using POJOs.
		<li>A remote proxy API built on top of REST.
		<li>A sophisticated INI config file API. 
		<li>A REST microservice API that combines all the features above for creating lightweight standalone REST interfaces that start up in milliseconds.
		<li>JAX-RS integration support for all serializers and parsers.
	</ul>
	<h5 class='toc'>Features</h5>
	<ul class='spaced-list'>
		<li>Marshalling support for JSON (including variants), XML, HTML, URL-Encoding, UON (URL-Encoded Object Notation), MessagePack, RDF/XML, RDF/XML-Abbrev, N-Triple, Turtle, N3, SOAP/XML.
		<li>Data Transfer Objects for HTML5, Atom, Cognos, JSON-Schema, and Swagger 2.0.  These can be serialized to any of the supported marshall types (e.g. ATOM/JSON, Swagger/XML, ...).
	</ul>
	
	<h5 class='toc'>Prerequisites</h5>
	<p>
		We've strived to keep prerequisites to an absolute minimum.
	</p>
	<ul class='spaced-list'>
		<li>The serializers and parsers require nothing more than Java 6+.
		<li>The RDF serializers and parsers require Apache Jena 2.5.1+.
		<li>The REST server API requires any Servlet 2.4+ container.
		<li>The REST client API requires Apache HttpClient 4.5+.
		<li>The REST microservice API requires Eclipse Jetty 8.1+.
	</ul>	
		
	<h5 class='toc'>Examples</h5>
	<p>
		Core library includes easy-to-use and customizable serializers and parsers.  The examples here are only a small taste of what's possible. 
	</p>
	<p>
		The default serializers can often be used to serialize POJOs in a single line of code:
	</p>
	<p class='bcode'>
	<jc>// A simple bean</jc>
	<jk>public class</jk> Person {
		<jk>public</jk> String name = <js>"John Smith"</js>;
		<jk>public int</jk> age = 21;
	}
	
	<jc>// Serialize a bean to JSON, XML, or HTML</jc>
	Person p = <jk>new</jk> Person();
	
	<jc>// Produces:
	// "{name:'John Smith',age:21}"</jc>
	String laxJson = JsonSerializer.<jsf>DEFAULT_LAX</jsf>.serialize(p);
	
	<jc>// Produces:
	// "{"name":"John Smith","age":21}"</jc>
	String strictJson = JsonSerializer.<jsf>DEFAULT</jsf>.serialize(p);
	
	<jc>// Produces:
	// &lt;object&gt;
	//   &lt;name&gt;John Smith&lt;/name&gt;
	//   &lt;age&gt;21&lt;/age&gt;
	// &lt;/object&gt;</jc>
	String xml = XmlSerializer.<jsf>DEFAULT_SIMPLE</jsf>.serialize(p);
	
	<jc>// Produces:
	// &lt;table&gt;
	//   &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;John Smith&lt;/td&gt;&lt;/tr&gt;
	//   &lt;tr&gt;&lt;td&gt;age&lt;/td&gt;&lt;td&gt;21&lt;/td&gt;&lt;/tr&gt;
	// &lt;/table&gt;</jc>
	String html = HtmlSerializer.<jsf>DEFAULT</jsf>.serialize(p);
	
	<jc>// Same as Html, but wraps it in HTML and BODY elements with page title/description/links:</jc>
	String htmlDoc = HtmlDocSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// name='John+Smith'&amp;age=21</jc>
	String urlEncoding = UrlEncodingSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// (name='John Smith',age=21)</jc>
	String uon = UonSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// 82 A4 name AA 4A John Smith 68 A3 age 15</jc>
	<jk>byte</jk>[] messagePack = MsgPackSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// &lt;rdf:RDF
	//  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	//  xmlns:jp="http://www.apache.org/juneaubp/"
	//  xmlns:j="http://www.apache.org/juneau/"&gt;
	// 	&lt;rdf:Description&gt;
	// 		&lt;jp:name&gt;John Smith&lt;/jp:name&gt;
	// 		&lt;jp:age&gt;21&lt;/jp:age&gt;
	// 	&lt;/rdf:Description&gt;
	// &lt;/rdf:RDF&gt;</jc>
	String rdfXml = RdfSerializer.<jsf>DEFAULT_XMLABBREV</jsf>.serialize(p);
	
	<jc>// Produces:
	// @prefix jp:      &lt;http://www.apache.org/juneaubp/&gt; .
	// @prefix j:       &lt;http://www.apache.org/juneau/&gt; .
	//	[]    jp:age  "21" ;
	//	      jp:name "John Smith" .</jc>
	String rdfN3 = RdfSerializer.<jsf>DEFAULT_N3</jsf>.serialize(p);

	<jc>// Produces:
	// _:A3bf53c85X3aX157cf407e2dX3aXX2dX7ffd &lt;http://www.apache.org/juneaubp/name&gt; "John Smith" .
	// _:A3bf53c85X3aX157cf407e2dX3aXX2dX7ffd &lt;http://www.apache.org/juneaubp/age&gt; "21" .</jc>
	String rdfNTriple = RdfSerializer.<jsf>DEFAULT_NTRIPLE</jsf>.serialize(p);
	</p>
	<p>
		Parsing back into POJOs is equally simple for any of the supported languages shown above (JSON shown here):
	</p>
	<p class='bcode'>
	<jc>// Use one of the predefined parsers.</jc>
	ReaderParser parser = JsonParser.<jsf>DEFAULT</jsf>;
	
	<jc>// Parse a JSON object (creates a generic ObjectMap).</jc>
	String json = <js>"{name:'John Smith',age:21}"</js>;
	Map m1 = parser.parse(json, Map.<jk>class</jk>);
	
	<jc>// Parse a JSON string.</jc>
	json = <js>"'foobar'"</js>;
	String s2 = parser.parse(json, String.<jk>class</jk>);
	
	<jc>// Parse a JSON number as a Long or Float.</jc>
	json = <js>"123"</js>;
	Long l3 = parser.parse(json, Long.<jk>class</jk>);
	Float f3 = parser.parse(json, Float.<jk>class</jk>);
	
	<jc>// Parse a JSON object as a bean.</jc>
	json = <js>"{name:'John Smith',age:21}"</js>;
	Person p4 = parser.parse(json, Person.<jk>class</jk>);
	
	<jc>// Parse a JSON object as a HashMap&lt;String,Person&gt;.</jc>
	json = <js>"{a:{name:'John Smith',age:21},b:{name:'Joe Smith',age:42}}"</js>;
	Map&lt;String,Person&gt; m5 = parser.parse(json, HashMap.<jk>class</jk>, String.<jk>class</jk>, Person.<jk>class</jk>);
	
	<jc>// Parse a JSON object as a HashMap&lt;String,LinkedList&lt;Person&gt;&gt;.</jc>
	json = <js>"{a:[{name:'John Smith',age:21},{name:'Joe Smith',age:42}]}"</js>;
	Map&lt;String,List&lt;Person&gt;&gt; m6 = parser.parse(json, HashMap.<jk>class</jk>, String.<jk>class</jk>, LinkedList.<jk>class</jk>, Person.<jk>class</jk>);

	<jc>// Parse a JSON array of integers as a Collection of Integers or int[] array.</jc>
	json = <js>"[1,2,3]"</js>;
	List&lt;Integer&gt; l7 = parser.parse(json, LinkedList.<jk>class</jk>, Integer.<jk>class</jk>);
	<jk>int</jk>[] i7 = parser.parse(json, <jk>int</jk>[].<jk>class</jk>);
	
	<jc>// Parse arbitrary input into ObjectMap or ObjectList objects 
	// (similar to JSONObject/JSONArray but generalized for all languages).</jc>
	json = <js>"{name:'John Smith',age:21}"</js>;
	ObjectMap m8a = parser.parse(json, ObjectMap.<jk>class</jk>);
	<jk>int</jk> age = m8a.getInt(<js>"age"</js>);
	ObjectMap m8b = (ObjectMap)parser.parse(json, Object.<jk>class</jk>);  <jc>// Equivalent.</jc>
	
	json = <js>"[1,true,null]"</js>;
	ObjectList l9a = parser.parse(json, ObjectList.<jk>class</jk>);  
	<jk>boolean</jk> b = l9a.getBoolean(1);
	ObjectList l9b = (ObjectList)parser.parse(json, Object.<jk>class</jk>);  <jc>// Equivalent.</jc>  
	</p>
	<p>
		Many POJOs such as primitives, beans, collections, arrays, and classes with various known constructors and methods are serializable out-of-the-box.  
		For other objects, "swaps" allow you to swap-in serializable replacement objects during serialization
		and vis-versa during parsing.  Beans can also be tailored in various ways such as customizing property names, ordering, and visibility.  
	</p>
	<p>
		See <a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#Core.PojoCategories'>POJO Categories</a> for a definition of supported POJOs.
	</p>
	<p>
		Serializers can send output directly to Writers, OutputStreams, Files, Strings, or byte arrays.
		<br>Parsers can receive input directly from Readers, InputStreams, Files, Strings, or byte arrays.
	</p>
	<br><br><hr>
	<p>
		<code>SerializerGroup</code> and <code>ParserGroup</code> classes allow serializers and parsers 
		to be retrieved by W3C-compliant HTTP <code>Accept</code> and <code>Content-Type</code> values:
	</p>
	<p class='bcode'>
	<jc>// Construct a new serializer group with configuration parameters that get applied to all serializers.</jc>
	SerializerGroup sg = <jk>new</jk> SerializerGroup()
		.append(JsonSerializer.<jk>class</jk>, UrlEncodingSerializer.<jk>class</jk>);
		.setUseWhitespace(<jk>true</jk>)
		.addPojoSwaps(CalendarSwap.ISO8601DT.<jk>class</jk>);

	<jc>// Find the appropriate serializer by Accept type and serialize our POJO to the specified writer.</jc>
	sg.getSerializer(<js>"text/invalid, text/json;q=0.8, text/*;q:0.6, *\/*;q=0.0"</js>)
		.serialize(myPersonObject, myWriter);
		
	<jc>// Construct a new parser group with configuration parameters that get applied to all parsers.</jc>
	ParserGroup pg = <jk>new</jk> ParserGroup()
		.append(JsonParser.<jk>class</jk>, UrlEncodingParser.<jk>class</jk>);
 		.addPojoSwaps(CalendarSwap.ISO8601DT.<jk>class</jk>);

	Person p = pg.getParser(<js>"text/json"</js>).parse(myReader, Person.<jk>class</jk>);
	</p>
	<br><br><hr>
	<p>
		Data Transfer Object libraries are provided for a variety of languages that allow you to serialize commonly-used
		documents.  
	</p>
	<p>	
		HTML5 documents and fragments can be constructed using the HTML5 DTOs and HTML or XML serializers:
	</p>
	<p class='bcode'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
		
	Object myform =
		<jsm>form</jsm>().action(<js>"/submit"</js>).method(<js>"POST"</js>)
		.children(
			<js>"Position (1-10000): "</js>, <jsm>input</jsm>(<js>"number"</js>).name(<js>"pos"</js>).value(1), <jsm>br</jsm>(),
			<js>"Limit (1-10000): "</js>, <jsm>input</jsm>(<js>"number"</js>).name(<js>"limit"</js>).value(100), <jsm>br</jsm>(),
			<jsm>button</jsm>(<js>"submit"</js>, <js>"Submit"</js>),
			<jsm>button</jsm>(<js>"reset"</js>, <js>"Reset"</js>)
		); 	

	String html = HtmlSerializer.<jsf>DEFAULT</jsf>.serialize(myform);
	</p>
	<p class='bcode'><xt>
		&lt;form <xa>action</xa>=<xs>'/submit'</xs> <xa>method</xa>=<xs>'POST'</xs>&gt;
			<xv>Position (1-10000):</xv> &lt;input <xa>name</xa>=<xs>'pos'</xs> <xa>type</xa>=<xs>'number'</xs> <xa>value</xa>=<xs>'1'</xs>/&gt;&lt;br/&gt;
			<xv>Limit (1-10000):</xv> &lt;input <xa>name</xa>=<xs>'pos'</xs> <xa>type</xa>=<xs>'number'</xs> <xa>value</xa>=<xs>'100'</xs>/&gt;&lt;br/&gt;
			&lt;button <xa>type</xa>=<xs>'submit'</xs>&gt;<xv>Submit</xv>&lt;/button&gt;
			&lt;button <xa>type</xa>=<xs>'reset'</xs>&gt;<xv>Reset</xv>&lt;/button&gt;			 
		&lt;/form&gt;
	</xt></p>
	<p>	
		ATOM feeds can be constructed using the ATOM DTOs and XML serializer:
	</p>
	<p class='bcode'>
	<jk>import static</jk> org.apache.juneau.dto.atom.AtomBuilder.*;
	
	Feed feed = 
		<jsm>feed</jsm>(<js>"tag:juneau.apache.org"</js>, <js>"Juneau ATOM specification"</js>, <js>"2016-01-02T03:04:05Z"</js>)
		.subtitle(<jsm>text</jsm>(<js>"html"</js>).text(<js>"Describes &lt;em&gt;stuff&lt;/em&gt; about Juneau"</js>))
		.links(
			<jsm>link</jsm>(<js>"alternate"</js>, <js>"text/html"</js>, <js>"http://juneau.apache.org/"</js>).hreflang(<js>"en"</js>),
			<jsm>link</jsm>(<js>"self"</js>, <js>"application/atom+xml"</js>, <js>"http://juneau.apache.org/feed.atom"</js>)
		)
		.rights(<js>"Copyright (c) 2016, Apache Foundation"</js>)
		.entries(
			<jsm>entry</jsm>(<js>"tag:juneau.sample.com,2013:1.2345"</js>, <js>"Juneau ATOM specification snapshot"</js>, <js>"2016-01-02T03:04:05Z"</js>)
			.published(<js>"2016-01-02T03:04:05Z"</js>)
			.content(
				<jsm>content</jsm>(<js>"xhtml"</js>)
				.lang(<js>"en"</js>)
				.base(<js>"http://www.apache.org/"</js>)
				.text(<js>"&lt;div&gt;&lt;p&gt;&lt;i&gt;[Update: Juneau supports ATOM.]&lt;/i&gt;&lt;/p&gt;&lt;/div&gt;"</js>)
			)
		);
	
	<jc>// Serialize to ATOM/XML</jc>
	String atomXml = XmlSerializer.<jsf>DEFAULT</jsf>.serialize(feed);
		</p>
		<p class='bcode'>
	<xt>&lt;feed&gt;</xt>
		<xt>&lt;id&gt;</xt>
			tag:juneau.apache.org
		<xt>&lt;/id&gt;</xt>
		<xt>&lt;link</xt> <xa>href</xa>=<xs>'http://juneau.apache.org/'</xs> <xa>rel</xa>=<xs>'alternate'</xs> <xa>type</xa>=<xs>'text/html'</xs> <xa>hreflang</xa>=<xs>'en'</xs>/<xt>&gt;</xt>
		<xt>&lt;link</xt> <xa>href</xa>=<xs>'http://juneau.apache.org/feed.atom'</xs> <xa>rel</xa>=<xs>'self'</xs> <xa>type</xa>=<xs>'application/atom+xml'</xs>/<xt>&gt;</xt>
		<xt>&lt;rights&gt;</xt>
			Copyright (c) 2016, Apache Foundation
		<xt>&lt;/rights&gt;</xt>
		<xt>&lt;title</xt> <xa>type</xa>=<xs>'text'</xs>&gt;</xt>
			Juneau ATOM specification
		<xt>&lt;/title&gt;</xt>
		<xt>&lt;updated&gt;</xt>2016-01-02T03:04:05Z<xt>&lt;/updated&gt;</xt>
		<xt>&lt;subtitle</xt> <xa>type</xa>=<xs>'html'</xs><xt>&gt;</xt>
			Describes &lt;em&gt;stuff&lt;/em&gt; about Juneau
		<xt>&lt;/subtitle&gt;</xt>
		<xt>&lt;entry&gt;</xt>
			<xt>&lt;id&gt;</xt>
				tag:juneau.apache.org
			<xt>&lt;/id&gt;</xt>
			<xt>&lt;title&gt;</xt>
				Juneau ATOM specification snapshot
			<xt>&lt;/title&gt;</xt>
			<xt>&lt;updated&gt;</xt>2016-01-02T03:04:05Z<xt>&lt;/updated&gt;</xt>
			<xt>&lt;content</xt> <xa>base</xa>=<xs>'http://www.apache.org/'</xs> <xa>lang</xa>=<xs>'en'</xs> <xa>type</xa>=<xs>'xhtml'</xs><xt>&gt;</xt>
				<xt>&lt;div</xt> <xa>xmlns</xa>=<xs>"http://www.w3.org/1999/xhtml"</xs><xt>&gt;&lt;p&gt;&lt;i&gt;</xt>[Update: Juneau supports ATOM.]<xt>&lt;/i&gt;&lt;/p&gt;&lt;/div&gt;</xt>
			<xt>&lt;/content&gt;</xt>
			<xt>&lt;published&gt;</xt>2016-01-02T03:04:05Z<xt>&lt;/published&gt;</xt>
		<xt>&lt;/entry&gt;</xt>
	<xt>&lt;/feed&gt;</xt>		
	</p>
	<p>	
		Swagger documents can be constructed using the Swagger DTOs and JSON serializer:
	</p>
	<p class='bcode'>
	<jk>import static</jk> org.apache.juneau.dto.swagger.SwaggerBuilder.*;

	Swagger swagger = <jsm>swagger</jsm>()
		.swagger(<js>"2.0"</js>)
		.info(
			<jsm>info</jsm>(<js>"Swagger Petstore"</js>, <js>"1.0.0"</js>)
				.description(<js>"This is a sample server Petstore server."</js>)
				.termsOfService(<js>"http://swagger.io/terms/"</js>)
				.contact(
					<jsm>contact</jsm>().email(<js>"apiteam@swagger.io"</js>)
				)
				.license(
					<jsm>license</jsm>(<js>"Apache 2.0"</js>).url(<js>"http://www.apache.org/licenses/LICENSE-2.0.html"</js>)
				)
		)
		.path(<js>"/pet"</js>, <js>"post"</js>,
			<jsm>operation</jsm>()
				.tags(<js>"pet"</js>)
				.summary(<js>"Add a new pet to the store"</js>)
				.description(<js>""</js>)
				.operationId(<js>"addPet"</js>)
				.consumes(MediaType.<jsf>JSON</jsf>, MediaType.<jsf>XML</jsf>)
				.produces(MediaType.<jsf>JSON</jsf>, MediaType.<jsf>XML</jsf>)
				.parameters(
					<jsm>parameterInfo</jsm>(<js>"body"</js>, <js>"body"</js>)
						.description(<js>"Pet object that needs to be added to the store"</js>)
						.required(<jk>true</jk>)
				)
				.response(405, <jsm>responseInfo</jsm>(<js>"Invalid input"</js>))
		);

	<jc>// Serialize to Swagger/JSON</jc>
	String swaggerJson = JsonSerializer.<jsf>DEFAULT_READABLE</jsf>.serialize(swagger);
	</p>
	<p class='bcode'>
	{
		<jf>"swagger"</jf>: <js>"2.0"</js>,
		<jf>"info"</jf>: {
			<jf>"title"</jf>: <js>"Swagger Petstore"</js>,
			<jf>"description"</jf>: <js>"This is a sample server Petstore server."</js>,
			<jf>"version"</jf>: <js>"1.0.0"</js>,
			<jf>"termsOfService"</jf>: <js>"http://swagger.io/terms/"</js>,
			<jf>"contact"</jf>: {
				<jf>"email"</jf>: <js>"apiteam@swagger.io"</js>
			},
			<jf>"license"</jf>: {
				<jf>"name"</jf>: <js>"Apache 2.0"</js>,
				<jf>"url"</jf>: <js>"http://www.apache.org/licenses/LICENSE-2.0.html"</js>
			}
		},
		<jf>"paths"</jf>: {
			<jf>"/pet"</jf>: {
				<jf>"post"</jf>: {
					<jf>"tags"</jf>: [
						<js>"pet"</js>
					],
					<jf>"summary"</jf>: <js>"Add a new pet to the store"</js>,
					<jf>"description"</jf>: <js>""</js>,
					<jf>"operationId"</jf>: <js>"addPet"</js>,
					<jf>"consumes"</jf>: [
						<js>"application/json"</js>,
						<js>"text/xml"</js>
					],
					<jf>"produces"</jf>: [
						<js>"application/json"</js>,
						<js>"text/xml"</js>
					],
					<jf>"parameters"</jf>: [
						{
							<jf>"in"</jf>: <js>"body"</js>,
							<jf>"name"</jf>: <js>"body"</js>,
							<jf>"description"</jf>: <js>"Pet object that needs to be added to the store"</js>,
							<jf>"required"</jf>: <jk>true</jk>
						}
					],
					<jf>"responses"</jf>: {
						<jf>"405"</jf>: {
							<jf>"description"</jf>: <js>"Invalid input"</js>
						}
					}
				}
			}
		},
	}		
	</p>
	<p>
		Note that these DTOs can also be serialized to any of the other supported languages such as JSON or MessagePack!
		And they can be parsed back into their original objects!
	</p>
	<br><br><hr>
	<p>
		The REST server API builds upon the <code>SerializerGroup</code> and <code>ParserGroup</code> classes 
		to provide annotated REST servlets that automatically negotiate the HTTP media types and allow the developer
		to work with requests, responses, headers, path variables, query parameters, and form data as POJOs.
	</p>
	<p>
		The end goal is to provide simple and flexible yet sophisticated REST interfaces that allow POJOs to be automatically represented as 
		different content types depending on whatever the particular need: 
	</p>
	<ul class='spaced-list'>
		<li>HTML for viewing POJOs in easy-to-read format in a browser.
		<li>JSON for interacting through Javascript.
		<li>XML for interacting with other applications.
		<li>RDF for interacting with triple stores.
		<li>URL-Encoding for interacting through HTML forms.
		<li>MessagePack for efficiently transmitting large amounts of data.
	</ul>
	<p>
		A simple example that supports all languages:
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/systemProperties"</js>,
		title=<js>"System properties resource"</js>
	)
	<jk>public class</jk> SystemPropertiesResource <jk>extends</jk> RestServletDefault {
	
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/"</js>)
		<jk>public</jk> Map getSystemProperties(<ja>@Query</ja>(<js>"sort"</js>) <jk>boolean</jk> sort) <jk>throws</jk> Throwable {
			<jk>if</jk> (sort)
				<jk>return new</jk> TreeMap(System.<jsm>getProperties</jsm>());
			<jk>return</jk> System.<jsm>getProperties</jsm>();
		}
	
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/{propertyName}"</js>)
		<jk>public</jk> String getSystemProperty(<ja>@Path</ja> String propertyName) <jk>throws</jk> Throwable {
			<jk>return</jk> System.<jsm>getProperty</jsm>(propertyName);
		}
	
		<ja>@RestMethod</ja>(name=<js>"PUT"</js>, path=<js>"/{propertyName}"</js>, guards=AdminGuard.<jk>class</jk>)
		<jk>public</jk> String setSystemProperty(<ja>@Path</ja> String propertyName, <ja>@Body</ja> String value) {
			System.<jsm>setProperty</jsm>(propertyName, value);
			<jk>return</jk> <js>"OK"</js>;
		}
	
		<ja>@RestMethod</ja>(name=<js>"POST"</js>, path=<js>"/"</js>, guards=AdminGuard.<jk>class</jk>)
		<jk>public</jk> String setSystemProperties(<ja>@Body</ja> java.util.Properties newProperties) {
			System.<jsm>setProperties</jsm>(newProperties);
			<jk>return</jk> <js>"OK"</js>;
		}
	
		<ja>@RestMethod</ja>(name=<js>"DELETE"</js>, path=<js>"/{propertyName}"</js>, guards=AdminGuard.<jk>class</jk>)
		<jk>public</jk> String deleteSystemProperty(<ja>@Path</ja> String propertyName) {
			System.<jsm>clearProperty</jsm>(propertyName);
			<jk>return</jk> <js>"OK"</js>;
		}
	}
	</p>
	<p>
		A more sophisticated example of the same resource using various features, including information
		for fully populating the Swagger documentation, guards for restricting access to particular
		methods, customizing supported content types and serialization options, adding g-zip compression, 
		and adding customized branding for the HTML views.
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/systemProperties"</js>,
		title=<js>"System properties resource"</js>,
		description=<js>"REST interface for performing CRUD operations on system properties."</js>,
		serializers={
			HtmlDocSerializer.<jk>class</jk>, 
			JsonSerializer.<jk>class</jk>,
			JsonSerializer.Simple.<jk>class</jk>,
			XmlDocSerializer.<jk>class</jk>,
			MsgPackSerializer.<jk>class</jk>
		},
		parsers={
			JsonParser.<jk>class</jk>,
			XmlParser.<jk>class</jk>,
			HtmlParser.<jk>class</jk>,
			MsgPackParser.<jk>class</jk>
		},
		properties={
			<ja>@Property</ja>(name=<jsf>SERIALIZER_quoteChar</jsf>, value=<js>"'"</js>),
			<ja>@Property</ja>(name=<jsf>HTMLDOC_links</jsf>, value=<js>"{up:'$R{requestParentURI}',options:'$R{servletURI}?method=OPTIONS'}"</js>),
		},
		stylesheet=<js>"styles/devops.css"</js>,
		encoders=GzipEncoder.<jk>class</jk>,
		contact=<js>"{name:'John Smith',email:'john@smith.com'}"</js>,
		license=<js>"{name:'Apache 2.0',url:'http://www.apache.org/licenses/LICENSE-2.0.html'}"</js>,
		version=<js>"2.0"</js>,
		termsOfService=<js>"You're on your own."</js>,
		tags=<js>"[{name:'Java',description:'Java utility',externalDocs:{description:'Home page',url:'http://juneau.apache.org'}}]"</js>,
		externalDocs=<js>"{description:'Home page',url:'http://juneau.apache.org'}"</js>
	)
	<jk>public class</jk> SystemPropertiesResource <jk>extends</jk> RestServlet {
	
		<ja>@RestMethod</ja>(
			name=<js>"GET"</js>, path=<js>"/"</js>,
			summary=<js>"Show all system properties"</js>,
			description=<js>"Returns all system properties defined in the JVM."</js>,
			parameters={
				<ja>@Parameter</ja>(in=<js>"query"</js>, name=<js>"sort"</js>, description=<js>"Sort results alphabetically."</js>, _default=<js>"false"</js>)
			},
			responses={
				<ja>@Response</ja>(value=200, description=<js>"Returns a map of key/value pairs."</js>)
			}
		)
		<jk>public</jk> Map getSystemProperties(<ja>@Query</ja>(<js>"sort"</js>) <jk>boolean</jk> sort) <jk>throws</jk> Throwable {
			<jk>if</jk> (sort)
				<jk>return new</jk> TreeMap(System.<jsm>getProperties</jsm>());
			<jk>return</jk> System.<jsm>getProperties</jsm>();
		}
	
		...
	}
	</p>
	<p>
		When combined with the support for HTML5 beans, simple HTML forms can be constructed for easy input and output
		using nothing more than Java:
	</p>
	<p class='bcode'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
	
	<ja>@RestMethod</ja>(
		name=<js>"GET"</js>, path=<js>"/formPage"</js>,
		summary=<js>"Form entry page"</js>,
		description=<js>"A form post page for setting a single system property value."</js>,
		guards=AdminGuard.<jk>class</jk>
	)
	<jk>public</jk> Form getFormPage() {
		<jk>return</jk> <jsm>form</jsm>().method(<js>"POST"</js>).action(<js>"formPagePost"</js>).children(
			<jsm>h4</jsm>(<js>"Set system property"</js>),
			<js>"Name: "</js>, <jsm>input</jsm>(<js>"text"</js>).name(<js>"name"</js>), <jsm>br</jsm>(),
			<js>"Value: "</js>, <jsm>input</jsm>(<js>"text"</js>).name(<js>"value"</js>), <jsm>br</jsm>(), <jsm>br</jsm>(),
			<jsm>button</jsm>(<js>"submit","Click me!"</js>).style(<js>"float:right"</js>)
		);
	}

	<ja>@RestMethod</ja>(
		name=<js>"POST"</js>, path=<js>"/formPagePost"</js>, 
		description=<js>"Accepts a simple form post of a system property name/value pair."</js>,
		guards=AdminGuard.<jk>class</jk>
	)
	<jk>public</jk> Redirect formPagePost(<ja>@FormData</ja>(<js>"name"</js>) String name, <ja>@FormData</ja>(<js>"value"</js>) String value) {
		System.<jsm>setProperty</jsm>(name, value);
		<jk>return new</jk> Redirect();  <jc>// Redirect to the servlet top page.</jc>
	}
	</p>	
	<img class='bordered' src='images/SystemPropertiesForm.png'>
	<p>
		The REST API is built on top of Servlets, making them easy to deploy in any JEE environment.  
		This allows you to use as much or as little of the Juneau technology as you wish.
		For example, if you wish to handle the response yourself, simply add the request and response objects to your method call and use
		the existing Servlet API methods to process the request and send a response:
	</p>
	<p class='bcode'>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/somePath"</js>)
	<jk>public void</jk> doLowLevelStuff(RestRequest req, RestResponse res) {
		<jc>// Do stuff with request and response objects.
		// These are subclasses of HttpServletRequest/HttpServletResponse with lots of
		// additional convenience methods.</jc>
	}
	</p>	
	<p>
		REST Java methods can return any of the following objects:  POJOs, Readers, InputStreams, ZipFiles, Redirects, Streamables, and Writables.
		<br>Or add your own handlers for other types.  
	</p>
	<p>
		REST Java methods can be passed any of the following objects in any order:
	</p>
	<ul>
		<li>Low-level request/response objects: HttpServletRequest, HttpServletResponse, RestRequest, RestResponse.
		<li>Path variables and remainder, query parameters, form parameters, HTTP method name, and header values as POJOs.
		<li>Other objects such as a ResourceBundle containing client-localized messages.
	</ul>
	<p>
		All parameter annotations also have programmatic equivalents on the RestRequest object.
		<br>As a general rule, anything done through annotations in Juneau has a programmatic equivalent. 
	</p>
	<p class='bcode'>
		<jd>/** Example GET request using annotated attributes */</jd> 
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/example1/{a1}/{a2}/{a3}/*"</js>) 
		<jk>public</jk> String doGetExample1( 
			<ja>@Method</ja> String method, 
			<ja>@Path</ja> String a1, 
			<ja>@Path</ja> <jk>int</jk> a2, 
			<ja>@Path</ja> UUID a3, 
			<ja>@Query</ja>(<js>"p1"</js>) <jk>int</jk> p1, 
			<ja>@Query</ja>(<js>"p2"</js>) String p2, 
			<ja>@Query</ja>(<js>"p3"</js>) UUID p3, 
			<ja>@PathRemainder</ja> String remainder, 
			<ja>@Header</ja>(<js>"Accept-Language"</js>) String lang, 
			<ja>@Header</ja>(<js>"Accept"</js>) String accept, 
			<ja>@Header</ja>(<js>"DNT"</js>) <jk>int</jk> doNotTrack 
		) { 
			String output = String.format( 
				<js>"method=%s, a1=%s, a2=%d, a3=%s, remainder=%s, p1=%d, p2=%s, p3=%s, lang=%s, accept=%s, dnt=%d"</js>, 
				method, a1, a2, a3, remainder, p1, p2, p3, lang, accept, doNotTrack); 
			<jk>return</jk> output; 
		} 
		
		<jd>/** Example GET request using methods on RestRequest and RestResponse */</jd> 
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/example2/{a1}/{a2}/{a3}/*"</js>) 
		<jk>public void</jk> doGetExample2(RestRequest req, RestResponse res) <jk>throws</jk> Exception { 
			String method = req.getMethod(); 
			
			<jc>// Attributes (from URL pattern variables)</jc> 
			String a1 = req.getPathParameter(<js>"a1"</js>, String.<jk>class</jk>); 
			<jk>int</jk> a2 = req.getPathParameter(<js>"a2"</js>, <jk>int</jk>.<jk>class</jk>); 
			UUID a3 = req.getPathParameter(<js>"a3"</js>, UUID.<jk>class</jk>); 
			
			<jc>// Optional GET parameters</jc> 
			<jk>int</jk> p1 = req.getQueryParameter(<js>"p1"</js>, <jk>int</jk>.<jk>class</jk>); 
			String p2 = req.getQueryParameter(<js>"p2"</js>, String.<jk>class</jk>); 
			UUID p3 = req.getQueryParameter(<js>"p3"</js>, UUID.<jk>class</jk>); 
			
			<jc>// URL pattern post-match</jc> 
			String remainder = req.getPathRemainder(); 
			
			<jc>// Headers</jc> 
			String lang = req.getHeader(<js>"Accept-Language"</js>); 
			<jk>int</jk> doNotTrack = req.getHeader(<js>"DNT"</js>, <jk>int</jk>.<jk>class</jk>); 
			
			<jc>// Send back a simple String response</jc> 
			String output = String.format( 
				<js>"method=%s, a1=%s, a2=%d, a3=%s, remainder=%s, p1=%d, p2=%s, p3=%s, lang=%s, dnt=%d"</js>, 
				method, a1, a2, a3, remainder, p1, p2, p3, lang, doNotTrack); 
			res.setOutput(output); 
		} 
	</p>
	<p>
		Auto-generated OPTIONS pages are constructed from Swagger DTO beans, here shown serialized as HTML:
	</p>
	<img class='bordered' src='images/Swagger.png'>
	<p>
		Swagger documentation can be populated from annotations (as above), resource bundles, or Swagger JSON files.
	</p>
	<p>
		The page shown above is implemented on the RestServletDefault class in the method below which shows that it's doing nothing more than 
		serializing a Swagger bean which is constructed in the RestRequest object:
	</p>
	<p class='bcode'>
	<ja>@RestMethod</ja>(name=<js>"OPTIONS"</js>, path=<js>"/*"</js>)
	<jk>public</jk> Swagger getOptions(RestRequest req) {
		<jk>return</jk> req.getSwagger();
	}
	</p>
	<p>
		Automatic error handling is provided for a variety of conditions: 
	</p>
	<ul>
		<li>Automatic 401 errors (Unauthorized) on failed guards.
		<li>Automatic 404 errors (Not Found) on unmatched path patterns.
		<li>Automatic 405 errors (Method Not Implemented) on unimplemented methods.
		<li>Automatic 406 errors (Not Acceptable) when no matching serializer was found to handle the <l>Accept</l> header.
		<li>Automatic 412 errors (Precondition Failed) when all matchers failed to match.
		<li>Automatic 415 errors (Unsupported Media Type) when no matching parser was found was found to handle the <l>Content-Type</l> header.
		<li>Automatic 500 errors on uncaught exceptions.
		<li>Throw your own runtime RestException with HTTP status and response object. 
	</ul>
	<p>
		Other features include: 
	</p> 
	<ul>
		<li>Extremely simple debuggability using nothing more than your browser.
		<li>Simplified localization support.
		<li>Configurability through external INI files.
		<li>Client-versioned responses (and other customizable heuristic matching APIs).
		<li>Define and use your own HTML stylesheets.
		<li>Optional JAX-RS integration.
		<li>Lots of up-to-date documentation and examples.
		<li>MUCH MORE!....
	</ul>
	<br><br><hr>
	<p>
		The REST client API allows you to access REST interfaces using POJOs as well:
	</p>
	<p class='bcode'>
	<jc>// Create a reusable JSON client.</jc>
	RestClient client = <jk>new</jk> RestClient(JsonSerializer.<jk>class</jk>, JsonParser.<jk>class</jk>);
	
	<jc>// The address of the root resource.</jc>
	String url = <js>"http://localhost:10000/systemProperties"</js>;
	
	<jc>// Do a REST GET against a remote REST interface and convert
	// the response to an unstructured ObjectMap object.</jc>
	Map m1 = client.doGet(url).getResponse(TreeMap.<jk>class</jk>);
	
	<jc>// Add some new system properties.
	// Use XML as the transport medium.</jc>
	client = <jk>new</jk> RestClient(XmlSerializer.<jk>class</jk>, XmlParser.<jk>class</jk>);
	Properties p = <jk>new</jk> Properties();
	p.load(reader);
	<jk>int</jk> returnCode = client.doPost(url + <js>"/systemProperties"</js>, p).execute();
	</p>
	<p>
		The client API uses the same serializers and parsers (and subsequently their flexibilty and configurability) as the server side to marshall POJOs back and forth.
	</p>
	<br><br><hr>
	<p>
		The remote proxy interface API allows you to invoke server-side POJO methods on the client side using REST:
	</p>
	<p class='bcode'>
	RestClient client = <jk>new</jk> RestClient(JsonSerializer.<jk>class</jk>, JsonParser.<jk>class</jk>)
		.setRemoteableUriServletUrl(<js>"https://localhost:9443/juneau/remote"</js>);
	 	
 	<jc>// Get an interface proxy.</jc>
 	IAddressBook ab = client.getRemoteableProxy(IAddressBook.<jk>class</jk>);
	
	<jc>// Invoke a method on the server side and get the returned result.</jc>
	Person p = ab.createPerson(
		<jk>new</jk> Person(
			<js>"John Smith"</js>, 
			<js>"Aug 1, 1999"</js>,
			<jk>new</jk> Address(<js>"My street"</js>, <js>"My city"</js>, <js>"My state"</js>, 12345, <jk>true</jk>)
		)
	);
	</p>
	<p>
		The server-side implementation of this is a simple specialized servlet with an abstract <code>getServiceMap()</code>
		method to define the server-side POJOs:
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/remote"</js>
	)
	<jk>public class</jk> SampleRemoteableServlet <jk>extends</jk> RemoteableServlet {
	
		<jc>// Our server-side POJO.</jc>
		AddressBook <jf>addressBook</jf> = <jk>new</jk> AddressBook();
	
		<ja>@Override</ja> <jc>/* RemoteableServlet */</jc>
		<jk>protected</jk> Map&lt;Class&lt;?&gt;,Object&gt; getServiceMap() <jk>throws</jk> Exception {
			Map&lt;Class&lt;?&gt;,Object&gt; m = <jk>new</jk> LinkedHashMap&lt;Class&lt;?&gt;,Object&gt;();
	
			<jc>// In this simplified example, we expose the same POJO service under two different interfaces.
			// One is IAddressBook which only exposes methods defined on that interface, and
			// the other is AddressBook itself which exposes all methods defined on the class itself (dangerous!).</jc>
			m.put(IAddressBook.<jk>class</jk>, <jf>addressBook</jf>);
			m.put(AddressBook.<jk>class</jk>, <jf>addressBook</jf>);
			<jk>return</jk> m;
		}
	}
	</p>
	<p>
		Parameters passed in on the client side are serialized (JSON in this case) as an HTTP POST, parsed on the
		server side, and then passed to the invocation method.  The returned POJO is then marshalled back as an HTTP response.
	</p>
	<p>
		The parameters and return types of the Java methods can be any of the supported serializable and parsable types in <a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#Core.PojoCategories'>POJO Categories</a>.
		This ends up being WAY more flexible than other proxy interfaces since Juneau can handle so may POJO types out-of-the-box.
		Most of the time you don't even need to modify your existing Java implementation code.
	</p>
	<p>
		The RemoteableServlet class itself shows how sophisticated REST interfaces can be built on the Juneau RestServlet
		API using very little code.  The RemoteableServlet class itself consists of only 53 lines of code, yet is
		a sophisticated discoverable and self-documenting REST interface.  And since the remote proxy API is built on top 
		of REST, it can be debugged using just a browser.
	</p>
	<br><br><hr>
	<p>
		The config file API allows you to interact with INI files using POJOs.  
		A sophisticated variable language is provided for referencing environment variables, system properties, other config file entries, and a host of other types.
	<p>
	<p class='bcode'>
	<cc>#--------------------------</cc>
	<cc># My section</cc>
	<cc>#--------------------------</cc>
	<cs>[MySection]</cs>
	
	<cc># An integer</cc>
	<ck>anInt</ck> = <cv>1</cv> 
	
	<cc># A boolean</cc>
	<ck>aBoolean</ck> = <cv>true</cv>
	
	<cc># An int array</cc>
	<ck>anIntArray</ck> = <cv>1,2,3</cv>
	
	<cc># A POJO that can be converted from a String</cc>
	<ck>aURL</ck> = <cv>http://foo </cv>
	
	<cc># A POJO that can be converted from JSON</cc>
	<ck>aBean</ck> = <cv>{foo:'bar',baz:123}</cv>
	
	<cc># A system property</cc>
	<ck>locale</ck> = <cv>$S{java.locale, en_US}</cv>
	
	<cc># An environment variable</cc>
	<ck>path</ck> = <cv>$E{PATH, unknown}</cv>
	
	<cc># A manifest file entry</cc>
	<ck>mainClass</ck> = <cv>$MF{Main-Class}</cv>
	
	<cc># Another value in this config file</cc>
	<ck>sameAsAnInt</ck> = <cv>$C{MySection/anInt}</cv>
	
	<cc># A command-line argument in the form "myarg=foo"</cc>
	<ck>myArg</ck> = <cv>$ARG{myarg}</cv>
	
	<cc># The first command-line argument</cc>
	<ck>firstArg</ck> = <cv>$ARG{0}</cv>

	<cc># Look for system property, or env var if that doesn't exist, or command-line arg if that doesn't exist.</cc>
	<ck>nested</ck> = <cv>$S{mySystemProperty,$E{MY_ENV_VAR,$ARG{0}}}</cv>

	<cc># A POJO with embedded variables</cc>
	<ck>aBean2</ck> = <cv>{foo:'$ARG{0}',baz:$C{MySection/anInt}}</cv>

		</p>
		<p>
			You're probably wondering "why INI files?"
			The beauty of these INI files is that they're easy to read and modify, yet sophisticated enough to allow you to
			store arbitrary-complex data structures and retrieve them as simple values or complex POJOs:
		</p>
		<p class='bcode'>
	<jc>// Load our config file</jc>
	ConfigFile f = ConfigMgr.<jsf>DEFAULT</jsf>.get(<js>"MyIniFile.cfg"</js>);
	
	<jk>int</jk> anInt = cf.getInt(<js>"MySection/anInt"</js>); 
	<jk>boolean</jk> aBoolean = cf.getBoolean(<js>"MySection/aBoolean"</js>); 
	<jk>int</jk>[] anIntArray = cf.getObject(<jk>int</jk>[].<jk>class</jk>, <js>"MySection/anIntArray"</js>); 
	URL aURL = cf.getObject(URL.<jk>class</jk>, <js>"MySection/aURL"</js>); 
	MyBean aBean = cf.getObject(MyBean.<jk>class</jk>, <js>"MySection/aBean"</js>); 
	Locale locale = cf.getObject(Locale.<jk>class</jk>, <js>"MySection/locale"</js>); 
	String path = cf.getString(<js>"MySection/path"</js>); 
	String mainClass = cf.getString(<js>"MySection/mainClass"</js>); 
	<jk>int</jk> sameAsAnInt = cf.getInt(<js>"MySection/sameAsAnInt"</js>); 
	String myArg = cf.getString(<js>"MySection/myArg"</js>); 
	String firstArg = cf.getString(<js>"MySection/firstArg"</js>); 
	</p>
	<p>
		One of the more powerful aspects of the REST servlets is that you can pull values directly from
		config files by using the <js>"$C"</js> variable in annotations.
		<br>For example, the HTML stylesheet for your REST servlet can be defined in a config file like so:
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/myResource"</js>,
		config=<js>"$S{my.config.file}"</js>,  <jc>// Path to config file (here pulled from a system property)</jc>
		stylesheet=<js>"$C{MyResourceSettings/myStylesheet}"</js>  <jc>// Stylesheet location pulled from config file.</jc>
	)
	<jk>public class</jk> MyResource <jk>extends</jk> RestServlet {
	</p>
	<p>
		The Config API also contains a listener API that allows you to, for example, reinitialize your REST
		resource if the config file changes, or listen for changes to particular sections or values.
	</p>
	<p>
		You can also modify INI files through the ConfigFile class (e.g. add/remove/modify sections and keys, add/remove comments and whitespace, etc...).
		<br>When using these APIs, you <b>DO NOT</b> lose formatting in your existing configuration file.
		All existing whitespace and comments are preserved for you!
	</p>
	<br><br><hr>
	<p>
		The microservice API combines all the features above with a built-in Jetty server to produce a lightweight 
		REST service packaged as two simple files:
	</p>
	<ul>
		<li>An executable jar file that starts up a REST interface in milliseconds.
		<li>An external INI file that can be used to configure your REST resources on the fly.
	</ul>
	<p>
		The microservice API was originally designed for and particularly suited for use in Docker containers.
	</p>
	<p>
		REST microservices can also be started programmatically in existing code:
	</p>
	<p class='bcode'>
	RestMicroservice myRestService = <jk>new</jk> RestMicroservice().setConfig(<js>"my-config.cfg"</js>, <jk>false</jk>);
	myRestService.start();
	URI uri = myRestService.getURI();
	</p>
	<p>
		The provided microservice.cfg template file gives you a starting point for defining your microservice:
	</p>
	<p class='bcode'>
	<cc>#================================================================================
	# Basic configuration file for SaaS microservices
	# Subprojects can use this as a starting point.
	#================================================================================</cc>
	
	<cc>#================================================================================
	# REST settings
	#================================================================================</cc>
	<cs>[REST]</cs>
	
	<cc># The HTTP port number to use.
	# Can be a comma-delimited list of ports to try.
	# 0 means try a random port.
	# Default is Rest-Port setting in manifest file, or 8000.
	# In this case, try port 10000, then try 3 random ports.</cc>
	<ck>port</ck> = <cv>10000, 0, 0, 0</cv>
	
	<cc># A JSON map of servlet paths to servlet classes.
	# Example:  
	# 	resourceMap = {'/*':'com.foo.MyServlet'}
	# Either resourceMap or resources must be specified.</cc>
	<ck>resourceMap</ck> = 

	<cc># A comma-delimited list of names of classes that extend from Servlet.
	# Resource paths are pulled from @RestResource.path() annotation, or
	# 	"/*" if annotation not specified.
	# Example:  
	# 	resources = com.foo.MyServlet
	# Default is Rest-Resources in manifest file.
	# Either resourceMap or resources must be specified.</cc>
	<ck>resources</ck> = 

	<cc># The context root of the Jetty server.
	# Default is Rest-ContextPath in manifest file, or "/".</cc>
	<ck>contextPath</ck> = 

	<cc># Authentication:  NONE, BASIC.</cc>
	<ck>authType</ck> = <cv>NONE</cv>
	
	<cc># The BASIC auth username.
	# Default is Rest-LoginUser in manifest file.</cc>
	<ck>loginUser</ck> = 
	
	<cc># The BASIC auth password.
	# Default is Rest-LoginPassword in manifest file.</cc>
	<ck>loginPassword</ck> = 
	
	<cc># The BASIC auth realm.
	# Default is Rest-AuthRealm in manifest file.</cc>
	<ck>authRealm</ck> = 
	
	<cc># Stylesheet to use for HTML views.
	# The default options are:
	#  - styles/juneau.css
	#  - styles/devops.css
	# Other stylesheets can be referenced relative to the servlet package or working
	# 	directory.</cc>
	<ck>stylesheet</ck> = <cv>styles/devops.css</cv>
	
	<cc># What to do when the config file is saved.
	# Possible values:
	# 	NOTHING - Don't do anything. 
	#	RESTART_SERVER - Restart the Jetty server.
	#	RESTART_SERVICE - Shutdown and exit with code '3'.</cc>
	<ck>saveConfigAction</ck> = <cv>RESTART_SERVER</cv>
	
	<cc># Enable SSL support.</cc>
	<ck>useSsl</ck> = <cv>true</cv>
	
	<cc>#================================================================================
	# Bean properties on the org.eclipse.jetty.util.ssl.SslSocketFactory class
	#--------------------------------------------------------------------------------
	# Ignored if REST/useSsl is false.
	#================================================================================</cc>
	<cs>[REST-SslContextFactory]</cs>
	<ck>keyStorePath</ck> = <cv>client_keystore.jks</cv>
	<ck>keyStorePassword*</ck> = <cv>{HRAaRQoT}</cv>
	<ck>excludeCipherSuites</ck> = <cv>TLS_DHE.*, TLS_EDH.*</cv>
	<ck>excludeProtocols</ck> = <cv>SSLv3</cv>
	<ck>allowRenegotiate</ck> = <cv>false</cv>
	
	<cc>#================================================================================
	# Logger settings
	# See FileHandler Java class for details.
	#================================================================================</cc>
	<cs>[Logging]</cs>

	<cc># The directory where to create the log file.
	# Default is "."</cc>
	<ck>logDir</ck> = <cv>logs</cv>
	
	<cc># The name of the log file to create for the main logger.
	# The logDir and logFile make up the pattern that's passed to the FileHandler
	# constructor.
	# If value is not specified, then logging to a file will not be set up.</cc>
	<ck>logFile</ck> = <cv>microservice.%g.log</cv>
	
	<cc># Whether to append to the existing log file or create a new one.
	# Default is false.</cc>
	<ck>append</ck> = 
	
	<cc># The SimpleDateFormat format to use for dates.
	# Default is "yyyy.MM.dd hh:mm:ss".</cc>
	<ck>dateFormat</ck> = 
	
	<cc># The log message format.
	# The value can contain any of the following variables:
	# 	{date} - The date, formatted per dateFormat.
	#	{class} - The class name.
	#	{method} - The method name.
	#	{logger} - The logger name.
	#	{level} - The log level name.
	#	{msg} - The log message.
	#	{threadid} - The thread ID.
	#	{exception} - The localized exception message.
	# Default is "[{date} {level}] {msg}%n".</cc>
	<ck>format</ck> =
	
	<cc># The maximum log file size.
	# Suffixes available for numbers.
	# See ConfigFile.getInt(String,int) for details.
	# Default is 1M.</cc>
	<ck>limit</ck> = <cv>10M</cv>
	
	<cc># Max number of log files.
	# Default is 1.</cc>
	<ck>count</ck> = <cv>5</cv>
	
	<cc># Default log levels.
	# Keys are logger names.
	# Values are serialized Level POJOs.</cc>
	<ck>levels</ck> = <cv>{ org.apache.juneau:'INFO' }</cv>
	
	<cc># Only print unique stack traces once and then refer to them by a simple 8 character hash identifier.
	# Useful for preventing log files from filling up with duplicate stack traces.
	# Default is false.</cc>
	<ck>useStackTraceHashes</ck> = <cv>true</cv>
	
	<cc># The default level for the console logger.
	# Default is WARNING.</cc>
	<ck>consoleLevel</ck> = 
	
	<cc>#================================================================================
	# System properties
	#--------------------------------------------------------------------------------
	# These are arbitrary system properties that are set during startup.
	#================================================================================</cc>
	<cs>[SystemProperties]</cs>
	
	<cc># Configure Jetty for StdErrLog Logging</cc>
	<ck>org.eclipse.jetty.util.log.class</ck> = <cv>org.eclipse.jetty.util.log.StrErrLog</cv>
	
	<cc># Jetty logging level</cc>
	<ck>org.eclipse.jetty.LEVEL</ck> = <cv>WARN</cv>		
	</p>
	<p>
		Various predefined reusable REST resource classes are provided for accessing log files, viewing and editing the config file, etc...
		These allow you to quickly put together sophisticated REST microservices.
	</p>
	<br><br><hr>
	<h5 class='toc'>More information</h5>
	<p>
		<b>*ALL*</b> user documentation for this project is maintained in its <a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/index.html' target="_top">Javadocs</a>.
		If it's not in the Javadocs, it doesn't exist.
	</p>
	<p>
		The top-level <a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#overview.description' target="_top">Overview</a> document is a good
		starting point for developers wishing to get up-to-speed quickly.
	</p>
	<p>
		Any questions about the project should be asked via email at <a href='mailto:dev@juneau.apache.org?Subject=Apache%20Juneau%20question'>dev@juneau.apache.org</a>.
	</p>
	<p align="center"><i><b>*** fi&#769;n ***</b></i></p>
	
	<!-- hitwebcounter Code START -->
	<a href="http://www.hitwebcounter.com" target="_blank">
		<img src="http://hitwebcounter.com/counter/counter.php?page=6608327&style=0007&nbdigits=7&type=page&initCount=0" title="" Alt=""  border="0" >
	</a>            
	<br/>
    <!-- hitwebcounter.com -->
    <a href="http://www.hitwebcounter.com" title="Hitwebcounter.com Free" target="_blank" style="font-family: Arial, Helvetica, sans-serif; font-size: 12px; color: #FFFFFF; text-decoration: underline ;"><strong>Hitwebcounter.com Free</strong></a>   	
</body>
</html>