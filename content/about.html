<!DOCTYPE html>
<html>
<head>
<style>
	@import url("styles/juneau-code.css");
	@import url("styles/juneau-doc.css");
</style>
</head>
<body>
	<h5 class='toc'>About</h5>
	<p>
		A single cohesive framework consisting of the following parts:
	</p>
	<ul class='spaced-list'>
		<li>A toolkit for marshalling POJOs to a variety of content types using a common framework.
		<li>A REST server API for creating Swagger-based self-documenting REST interfaces using POJOs.
		<li>A REST client API for interacting with REST interfaces using POJOs.
		<li>A remote interface proxy API built on top of REST that allows you to create proxy interfaces against Juneau or 3rd-party REST interfaces.
		<li>A sophisticated INI config file API. 
		<li>A REST microservice API that combines all the features above for creating lightweight standalone REST interfaces that start up in milliseconds.
	</ul>
	<p>
		Questions via email to <a class='doclink' href='mailto:dev@juneau.apache.org?Subject=Apache%20Juneau%20question'>dev@juneau.apache.org</a> are always welcome.
	</p>
	<h5 class='toc'>Features</h5>
	<ul class='spaced-list'>
		<li>Marshalling support for:
			<ul>
				<li>JSON (including variants, lax syntax, support for comments, fully RFC1759 compliant, plus JSON-Schema)
				<li>XML (including namespace support, plus XML-Schema)
				<li>HTML (plus HTML-Schema)
				<li>URL-Encoding
				<li>UON (URL-Encoded Object Notation)
				<li>MessagePack
				<li>RDF/XML
				<li>RDF/XML-Abbrev 
				<li>N-Triple
				<li>Turtle
				<li>N3
				<li>CSV
				<li>SOAP/XML
				<li>Coming soon: Protocol Buffer (proto3), YAML, BSON
			</ul>
		<li>Data Transfer Objects for:
			<ul>
				<li>HTML5
				<li>Atom
				<li>Cognos
				<li>JSON-Schema
				<li>Swagger 2.0
			</ul>
		<li>KISS is our mantra!  No auto-wiring.  No code generation.  No dependency injection.  Just give it POJOs.  Extremely simple unit testing!
		<li>Does not use intermediate DOMs!  POJOs are serialized directly to streams and parsed back directly to POJOs.  Extremely efficient and fast.
		<li>Tiny - ~1MB
		<li>Exhaustively tested
	</ul>
	
	<h5 class='toc'>Prerequisites</h5>
	<p>
		We've strived to keep prerequisites to an absolute minimum.
	</p>
	<ul class='spaced-list'>
		<li>The serializers and parsers require nothing more than Java 6+.
		<li>The RDF serializers and parsers require Apache Jena 2.5.1+.
		<li>The REST server API requires any Servlet 2.4+ container.
		<li>The REST client API requires Apache HttpClient 4.5+.
		<li>The REST microservice API requires Eclipse Jetty 8.1+.
	</ul>	
		
	<h5 class='toc'>Components</h5>
	<p>
		The library consists of 4 components/jars, and a single uber-jar that contains everything. 
	</p>
	<img src='images/Components.png'>

	<h5 class='toc'>Juneau Core</h5>
	<p>
		Core library includes easy-to-use and customizable serializers and parsers.  The examples here are only a small taste of what's possible. 
	</p>
	<p>
		The default serializers can often be used to serialize POJOs in a single line of code:
	</p>
	<p class='bcode'>
	<jc>// A simple bean</jc>
	<jk>public class</jk> Person {
		<jk>public</jk> String name = <js>"John Smith"</js>;
		<jk>public int</jk> age = 21;
	}
	
	<jc>// Serialize a bean to JSON, XML, or HTML</jc>
	Person p = <jk>new</jk> Person();
	
	<jc>// Produces:
	// "{name:'John Smith',age:21}"</jc>
	String laxJson = JsonSerializer.<jsf>DEFAULT_LAX</jsf>.serialize(p);
	
	<jc>// Produces:
	// "{"name":"John Smith","age":21}"</jc>
	String strictJson = JsonSerializer.<jsf>DEFAULT</jsf>.serialize(p);
	
	<jc>// Produces:
	// &lt;object&gt;
	//   &lt;name&gt;John Smith&lt;/name&gt;
	//   &lt;age&gt;21&lt;/age&gt;
	// &lt;/object&gt;</jc>
	String xml = XmlSerializer.<jsf>DEFAULT_SIMPLE</jsf>.serialize(p);
	
	<jc>// Produces:
	// &lt;table&gt;
	//   &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;John Smith&lt;/td&gt;&lt;/tr&gt;
	//   &lt;tr&gt;&lt;td&gt;age&lt;/td&gt;&lt;td&gt;21&lt;/td&gt;&lt;/tr&gt;
	// &lt;/table&gt;</jc>
	String html = HtmlSerializer.<jsf>DEFAULT</jsf>.serialize(p);
	
	<jc>// Same as Html, but wraps it in HTML and BODY elements with page title/description/links:</jc>
	String htmlDoc = HtmlDocSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// name='John+Smith'&amp;age=21</jc>
	String urlEncoding = UrlEncodingSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// (name='John Smith',age=21)</jc>
	String uon = UonSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// 82 A4 name AA 4A John Smith 68 A3 age 15</jc>
	<jk>byte</jk>[] messagePack = MsgPackSerializer.<jsf>DEFAULT</jsf>.serialize(p);

	<jc>// Produces:
	// &lt;rdf:RDF
	//  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	//  xmlns:jp="http://www.apache.org/juneaubp/"
	//  xmlns:j="http://www.apache.org/juneau/"&gt;
	// 	&lt;rdf:Description&gt;
	// 		&lt;jp:name&gt;John Smith&lt;/jp:name&gt;
	// 		&lt;jp:age&gt;21&lt;/jp:age&gt;
	// 	&lt;/rdf:Description&gt;
	// &lt;/rdf:RDF&gt;</jc>
	String rdfXml = RdfSerializer.<jsf>DEFAULT_XMLABBREV</jsf>.serialize(p);
	
	<jc>// Produces:
	// @prefix jp:      &lt;http://www.apache.org/juneaubp/&gt; .
	// @prefix j:       &lt;http://www.apache.org/juneau/&gt; .
	//	[]    jp:age  "21" ;
	//	      jp:name "John Smith" .</jc>
	String rdfN3 = RdfSerializer.<jsf>DEFAULT_N3</jsf>.serialize(p);

	<jc>// Produces:
	// _:A3bf53c85X3aX157cf407e2dX3aXX2dX7ffd &lt;http://www.apache.org/juneaubp/name&gt; "John Smith" .
	// _:A3bf53c85X3aX157cf407e2dX3aXX2dX7ffd &lt;http://www.apache.org/juneaubp/age&gt; "21" .</jc>
	String rdfNTriple = RdfSerializer.<jsf>DEFAULT_NTRIPLE</jsf>.serialize(p);
	</p>
	<p>
		Parsing back into POJOs is equally simple for any of the supported languages shown above (JSON shown here):
	</p>
	<p class='bcode'>
	<jc>// Use one of the predefined parsers.</jc>
	ReaderParser parser = JsonParser.<jsf>DEFAULT</jsf>;
	
	<jc>// Parse a JSON object (creates a generic ObjectMap).</jc>
	String json = <js>"{name:'John Smith',age:21}"</js>;
	Map m1 = parser.parse(json, Map.<jk>class</jk>);
	
	<jc>// Parse a JSON string.</jc>
	json = <js>"'foobar'"</js>;
	String s2 = parser.parse(json, String.<jk>class</jk>);
	
	<jc>// Parse a JSON number as a Long or Float.</jc>
	json = <js>"123"</js>;
	Long l3 = parser.parse(json, Long.<jk>class</jk>);
	Float f3 = parser.parse(json, Float.<jk>class</jk>);
	
	<jc>// Parse a JSON object as a bean.</jc>
	json = <js>"{name:'John Smith',age:21}"</js>;
	Person p4 = parser.parse(json, Person.<jk>class</jk>);
	
	<jc>// Parse a JSON object as a HashMap&lt;String,Person&gt;.</jc>
	json = <js>"{a:{name:'John Smith',age:21},b:{name:'Joe Smith',age:42}}"</js>;
	Map&lt;String,Person&gt; m5 = parser.parse(json, HashMap.<jk>class</jk>, String.<jk>class</jk>, Person.<jk>class</jk>);
	
	<jc>// Parse a JSON object as a HashMap&lt;String,LinkedList&lt;Person&gt;&gt;.</jc>
	json = <js>"{a:[{name:'John Smith',age:21},{name:'Joe Smith',age:42}]}"</js>;
	Map&lt;String,List&lt;Person&gt;&gt; m6 = parser.parse(json, HashMap.<jk>class</jk>, String.<jk>class</jk>, LinkedList.<jk>class</jk>, Person.<jk>class</jk>);

	<jc>// Parse a JSON array of integers as a Collection of Integers or int[] array.</jc>
	json = <js>"[1,2,3]"</js>;
	List&lt;Integer&gt; l7 = parser.parse(json, LinkedList.<jk>class</jk>, Integer.<jk>class</jk>);
	<jk>int</jk>[] i7 = parser.parse(json, <jk>int</jk>[].<jk>class</jk>);
	
	<jc>// Parse arbitrary input into ObjectMap or ObjectList objects 
	// (similar to JSONObject/JSONArray but generalized for all languages).</jc>
	json = <js>"{name:'John Smith',age:21}"</js>;
	ObjectMap m8a = parser.parse(json, ObjectMap.<jk>class</jk>);
	<jk>int</jk> age = m8a.getInt(<js>"age"</js>);
	ObjectMap m8b = (ObjectMap)parser.parse(json, Object.<jk>class</jk>);  <jc>// Equivalent.</jc>
	
	json = <js>"[1,true,null]"</js>;
	ObjectList l9a = parser.parse(json, ObjectList.<jk>class</jk>);  
	<jk>boolean</jk> b = l9a.getBoolean(1);
	ObjectList l9b = (ObjectList)parser.parse(json, Object.<jk>class</jk>);  <jc>// Equivalent.</jc>  
	</p>
	<p>
		Serializers can send output directly to Writers, OutputStreams, Files, Strings, or byte arrays.
		<br>Parsers can receive input directly from Readers, InputStreams, Files, Strings, or byte arrays.
	</p>
	<br><br><hr>
	<p>
		Serializers and parsers are builder-based.  Build from scratch or clone existing instances.  Lots of configuration options available for all the languages.
	</p>
	<p class='bcode'>
	<jc>// Create a serializer from scratch using a builder</jc>
	JsonSerializer serializer = <jk>new</jk> JsonSerializerBuilder()
	   .simple()                                  <jc>// simple mode</jc>
	   .sq()                                      <jc>// use single quotes</jc>
	   .pojoSwaps(                                
	      IteratorSwap.<jk>class</jk>,
	      ByteArrayBase64Swap.<jk>class</jk>,
	      CalendarSwap.ISO8601DT.<jk>class</jk>,
	   )
	   .beanFilters(MyBeanFilter.<jk>class</jk>)
	   .timeZone(TimeZone.<jsf>GMT</jsf>)
	   .locale(Locale.<jsf>JAPAN</jsf>)
	   .sortCollections(<jk>true</jk>)
	   .sortProperties(<jk>true</jk>)
	   .trimNullProperties(<jk>true</jk>)
	   .trimStrings(<jk>true</jk>)
	   .methodVisibility(<jsf>PROTECTED</jsf>)  
	   .beanDictionary(MyBeanA.<jk>class</jk>, MyBeanB.<jk>class</jk>)
	   .debug(<jk>true</jk>)
	   .build();
	   
	<jc>// Clone an existing serializer and modify it to use single-quotes</jc>
	JsonSerializer serializer = JsonSerializer.<jsf>DEFAULT</jsf>.builder()
	   .sq()
	   .build();	
	</p>
	<br><br><hr>
	<p>
		Many POJOs such as primitives, beans, collections, arrays, and classes with various known constructors and methods are serializable out-of-the-box.  
		For other objects, "swaps" allow you to swap-in serializable replacement objects during serialization
		and vis-versa during parsing.  Beans can also be tailored in various ways such as customizing property names, ordering, and visibility.  
	</p>
	<ul class='spaced-list'>
		<li>Transforms
			<ul>
				<li>Bean filters - Control how bean properties are handled (naming conventions, ordering, visibility,...).
				<li>POJO swaps - Replace non-serializable POJOs with serializable equivalents.
					<br>Predefined swaps provided for common cases: <code>ByteArrayBase64Swap</code>, 50+ variants of Calendar/Date swaps, <code>Enumeration/Iterator</code> swaps
			</ul>
		<li>Annotations 
			<br>Various annotations available for your POJO classes that are recognized by all serializers and parsers:  
			<br><ja>@Bean</ja>, <ja>@Pojo</ja>, <ja>@BeanIgnore</ja>, <ja>@BeanParam</ja>, <ja>@BeanProperty</ja>, <ja>@NameProperty</ja>, <ja>@ParentProperty</ja>
			<br>All annotations have programmatic equivalents when you don't have access to POJO source.
		<li>Swap methods
			<br>By default, various instance and static methods and constructors are automatically detected and supported:
			<br><code>valueOf(String)</code>, <code>parse(String)</code>, <code>parseString(String)</code>, <code>forName(String)</code>, <code>forString(String)</code>, 
				<code>fromString(String)</code>, <code>T(String)</code>, <code>Object swap(BeanSession)</code>, <code>T unswap(BeanSession, T.class)</code>
	</ul>
	<p>
		See <a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#Core.PojoCategories'>POJO Categories</a> for a definition of supported POJOs.
	</p>
	<br><br><hr>
	<p>
		UON (URL-Encoded Object Notation) allows JSON-like data structures (OBJECT, ARRAY, NUMBER, BOOLEAN, STRING, NULL) in HTTP constructs (query parameters, form parameters,
		headers, URL parts) without violating RFC2396.
		This allows POJOs to be converted directly into HTTP constructs.
	</p>
	<p class='bcode'>
	(
		id=1, 
		name=<js>'John+Smith'</js>, 
		uri=<js>http://sample/addressBook/person/1</js>, 
		addressBookUri=<js>http://sample/addressBook</js>,
		birthDate=<js>1946-08-12T00:00:00Z</js>,
		addresses=@(
			(
				uri=<js>http://sample/addressBook/address/1</js>, 
				personUri=<js>http://sample/addressBook/person/1</js>, 
				id=<js>1</js>, 
				street=<js>'100+Main+Street'</js>, 
				city=<js>Anywhereville</js>, 
				state=<js>NY</js>, 
				zip=<js>12345</js>, 
				isCurrent=<jk>true</jk>
			)
		)
	)
	</p>
	<br><br><hr>
	<p>
		Lots of shortcuts are provided throughout the API to simplify tasks, and the APIs are often useful for debugging and logging purposes as well...
	</p>
	<p class='bcode'>
	<jc>// Create JSON strings from scratch using fluent-style code.</jc>
	String jsonObject = <jk>new</jk> ObjectMap().append(<js>"foo"</js>,<js>"bar"</js>).toString(); 
	String jsonArray = <jk>new</jk> ObjectList().append(<js>"foo"</js>).append(123).append(<jk>null</jk>).toString(); 
	
	<jc>// Create maps and beans directly from JSON.</jc>
	Map&lt;String,Object&gt; myMap = <jk>new</jk> ObjectMap(<js>"{foo:'bar'}"</js>); 
	List&lt;Object&gt; myList = <jk>new</jk> ObjectList(<js>"['foo',123,null]"</js>); 

	<jc>// Load a POJO from a JSON file.</jc>
	MyPojo myPojo = JsonParser.<jsf>DEFAULT</jsf>.parse(<jk>new</jk> File(<js>"myPojo.json"</js>));

	<jc>// Serialize POJOs and ignore exceptions (great for logging)</jc>
	String json = JsonSerializer.<jsf>DEFAULT_LAX</jsf>.toString(myPojo);
	
	<jc>// Dump a POJO to the console.</jc>
	JsonSerializer.<jsf>DEFAULT_LAX</jsf>.println(myPojo);
	
	<jc>// Delayed serialization.</jc>
	<jc>// (e.g. don't serialize an object if it's not going to be logged).</jc>
	logger.log(<jsf>FINE</jsf>, <js>"My POJO was: {0}"</js>, <jk>new</jk> StringObject(myPojo));
	logger.log(<jsf>FINE</jsf>, <js>"My POJO in XML was: {0}"</js>, <jk>new</jk> StringObject(XmlSerializer.<jsf>DEFAULT</jsf>, myPojo));
	
	String message = <jk>new</jk> StringMessage(<js>"My POJO in {0}: {1}"</js>, <js>"JSON"</js>, <jk>new</jk> StringObject(myPojo)).toString();
	
	<jc>// Create a 'REST' wrapper around a POJO.</jc>
	PojoRest pojoRest = <jk>new</jk> PojoRest(myPojo);
	pojoRest.get(String.<jk>class</jk>, <js>"addressBook/0/name"</js>);
	pojoRest.put(<js>"addressBook/0/name"</js>, <js>"John Smith"</js>);
	</p>
	<br><br><hr>
	<p>
		<code>SerializerGroup</code> and <code>ParserGroup</code> classes allow serializers and parsers 
		to be retrieved by W3C-compliant HTTP <code>Accept</code> and <code>Content-Type</code> values:
	</p>
	<p class='bcode'>
	<jc>// Construct a new serializer group with configuration parameters that get applied to all serializers.</jc>
	SerializerGroup sg = <jk>new</jk> SerializerGroupBuilder()
		.append(JsonSerializer.<jk>class</jk>, UrlEncodingSerializer.<jk>class</jk>);
		.ws()   <jc>// or .setUseWhitespace(true)</jc>
		.pojoSwaps(CalendarSwap.ISO8601DT.<jk>class</jk>)
		.build();

	<jc>// Find the appropriate serializer by Accept type and serialize our POJO to the specified writer.</jc>
	sg.getSerializer(<js>"text/invalid, text/json;q=0.8, text/*;q:0.6, *\/*;q=0.0"</js>)
		.serialize(myPersonObject, myWriter);
		
	<jc>// Construct a new parser group with configuration parameters that get applied to all parsers.</jc>
	ParserGroup pg = <jk>new</jk> ParserGroupBuilder()
		.append(JsonParser.<jk>class</jk>, UrlEncodingParser.<jk>class</jk>);
 		.pojoSwaps(CalendarSwap.ISO8601DT.<jk>class</jk>)
 		.build();

	Person p = pg.getParser(<js>"text/json"</js>).parse(myReader, Person.<jk>class</jk>);
	</p>

	<h5 class='toc'>DTO libraries</h5>
	<p>
		Data Transfer Object libraries are provided for a variety of languages that allow you to serialize commonly-used
		documents.  
	</p>
	<p>	
		HTML5 documents and fragments can be constructed using the HTML5 DTOs and HTML or XML serializers:
	</p>
	<p class='bcode'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
		
	Object myform =
		<jsm>form</jsm>().action(<js>"/submit"</js>).method(<js>"POST"</js>)
		.children(
			<js>"Position (1-10000): "</js>, <jsm>input</jsm>(<js>"number"</js>).name(<js>"pos"</js>).value(1), <jsm>br</jsm>(),
			<js>"Limit (1-10000): "</js>, <jsm>input</jsm>(<js>"number"</js>).name(<js>"limit"</js>).value(100), <jsm>br</jsm>(),
			<jsm>button</jsm>(<js>"submit"</js>, <js>"Submit"</js>),
			<jsm>button</jsm>(<js>"reset"</js>, <js>"Reset"</js>)
		); 	

	String html = HtmlSerializer.<jsf>DEFAULT</jsf>.serialize(myform);
	</p>
	<p class='bcode'><xt>
		&lt;form <xa>action</xa>=<xs>'/submit'</xs> <xa>method</xa>=<xs>'POST'</xs>&gt;
			<xv>Position (1-10000):</xv> &lt;input <xa>name</xa>=<xs>'pos'</xs> <xa>type</xa>=<xs>'number'</xs> <xa>value</xa>=<xs>'1'</xs>/&gt;&lt;br/&gt;
			<xv>Limit (1-10000):</xv> &lt;input <xa>name</xa>=<xs>'pos'</xs> <xa>type</xa>=<xs>'number'</xs> <xa>value</xa>=<xs>'100'</xs>/&gt;&lt;br/&gt;
			&lt;button <xa>type</xa>=<xs>'submit'</xs>&gt;<xv>Submit</xv>&lt;/button&gt;
			&lt;button <xa>type</xa>=<xs>'reset'</xs>&gt;<xv>Reset</xv>&lt;/button&gt;			 
		&lt;/form&gt;
	</xt></p>
	<p>	
		ATOM feeds can be constructed using the ATOM DTOs and XML serializer:
	</p>
	<p class='bcode'>
	<jk>import static</jk> org.apache.juneau.dto.atom.AtomBuilder.*;
	
	Feed feed = 
		<jsm>feed</jsm>(<js>"tag:juneau.apache.org"</js>, <js>"Juneau ATOM specification"</js>, <js>"2016-01-02T03:04:05Z"</js>)
		.subtitle(<jsm>text</jsm>(<js>"html"</js>).text(<js>"Describes &lt;em&gt;stuff&lt;/em&gt; about Juneau"</js>))
		.links(
			<jsm>link</jsm>(<js>"alternate"</js>, <js>"text/html"</js>, <js>"http://juneau.apache.org/"</js>).hreflang(<js>"en"</js>),
			<jsm>link</jsm>(<js>"self"</js>, <js>"application/atom+xml"</js>, <js>"http://juneau.apache.org/feed.atom"</js>)
		)
		.rights(<js>"Copyright (c) 2016, Apache Foundation"</js>)
		.entries(
			<jsm>entry</jsm>(<js>"tag:juneau.sample.com,2013:1.2345"</js>, <js>"Juneau ATOM specification snapshot"</js>, <js>"2016-01-02T03:04:05Z"</js>)
			.published(<js>"2016-01-02T03:04:05Z"</js>)
			.content(
				<jsm>content</jsm>(<js>"xhtml"</js>)
				.lang(<js>"en"</js>)
				.base(<js>"http://www.apache.org/"</js>)
				.text(<js>"&lt;div&gt;&lt;p&gt;&lt;i&gt;[Update: Juneau supports ATOM.]&lt;/i&gt;&lt;/p&gt;&lt;/div&gt;"</js>)
			)
		);
	
	<jc>// Serialize to ATOM/XML</jc>
	String atomXml = XmlSerializer.<jsf>DEFAULT</jsf>.serialize(feed);
		</p>
		<p class='bcode'>
	<xt>&lt;feed&gt;</xt>
		<xt>&lt;id&gt;</xt>
			tag:juneau.apache.org
		<xt>&lt;/id&gt;</xt>
		<xt>&lt;link</xt> <xa>href</xa>=<xs>'http://juneau.apache.org/'</xs> <xa>rel</xa>=<xs>'alternate'</xs> <xa>type</xa>=<xs>'text/html'</xs> <xa>hreflang</xa>=<xs>'en'</xs>/<xt>&gt;</xt>
		<xt>&lt;link</xt> <xa>href</xa>=<xs>'http://juneau.apache.org/feed.atom'</xs> <xa>rel</xa>=<xs>'self'</xs> <xa>type</xa>=<xs>'application/atom+xml'</xs>/<xt>&gt;</xt>
		<xt>&lt;rights&gt;</xt>
			Copyright (c) 2016, Apache Foundation
		<xt>&lt;/rights&gt;</xt>
		<xt>&lt;title</xt> <xa>type</xa>=<xs>'text'</xs>&gt;</xt>
			Juneau ATOM specification
		<xt>&lt;/title&gt;</xt>
		<xt>&lt;updated&gt;</xt>2016-01-02T03:04:05Z<xt>&lt;/updated&gt;</xt>
		<xt>&lt;subtitle</xt> <xa>type</xa>=<xs>'html'</xs><xt>&gt;</xt>
			Describes &lt;em&gt;stuff&lt;/em&gt; about Juneau
		<xt>&lt;/subtitle&gt;</xt>
		<xt>&lt;entry&gt;</xt>
			<xt>&lt;id&gt;</xt>
				tag:juneau.apache.org
			<xt>&lt;/id&gt;</xt>
			<xt>&lt;title&gt;</xt>
				Juneau ATOM specification snapshot
			<xt>&lt;/title&gt;</xt>
			<xt>&lt;updated&gt;</xt>2016-01-02T03:04:05Z<xt>&lt;/updated&gt;</xt>
			<xt>&lt;content</xt> <xa>base</xa>=<xs>'http://www.apache.org/'</xs> <xa>lang</xa>=<xs>'en'</xs> <xa>type</xa>=<xs>'xhtml'</xs><xt>&gt;</xt>
				<xt>&lt;div</xt> <xa>xmlns</xa>=<xs>"http://www.w3.org/1999/xhtml"</xs><xt>&gt;&lt;p&gt;&lt;i&gt;</xt>[Update: Juneau supports ATOM.]<xt>&lt;/i&gt;&lt;/p&gt;&lt;/div&gt;</xt>
			<xt>&lt;/content&gt;</xt>
			<xt>&lt;published&gt;</xt>2016-01-02T03:04:05Z<xt>&lt;/published&gt;</xt>
		<xt>&lt;/entry&gt;</xt>
	<xt>&lt;/feed&gt;</xt>		
	</p>
	<p>	
		Swagger documents can be constructed using the Swagger DTOs and JSON serializer:
	</p>
	<p class='bcode'>
	<jk>import static</jk> org.apache.juneau.dto.swagger.SwaggerBuilder.*;

	Swagger swagger = <jsm>swagger</jsm>()
		.swagger(<js>"2.0"</js>)
		.info(
			<jsm>info</jsm>(<js>"Swagger Petstore"</js>, <js>"1.0.0"</js>)
				.description(<js>"This is a sample server Petstore server."</js>)
				.termsOfService(<js>"http://swagger.io/terms/"</js>)
				.contact(
					<jsm>contact</jsm>().email(<js>"apiteam@swagger.io"</js>)
				)
				.license(
					<jsm>license</jsm>(<js>"Apache 2.0"</js>).url(<js>"http://www.apache.org/licenses/LICENSE-2.0.html"</js>)
				)
		)
		.path(<js>"/pet"</js>, <js>"post"</js>,
			<jsm>operation</jsm>()
				.tags(<js>"pet"</js>)
				.summary(<js>"Add a new pet to the store"</js>)
				.description(<js>""</js>)
				.operationId(<js>"addPet"</js>)
				.consumes(MediaType.<jsf>JSON</jsf>, MediaType.<jsf>XML</jsf>)
				.produces(MediaType.<jsf>JSON</jsf>, MediaType.<jsf>XML</jsf>)
				.parameters(
					<jsm>parameterInfo</jsm>(<js>"body"</js>, <js>"body"</js>)
						.description(<js>"Pet object that needs to be added to the store"</js>)
						.required(<jk>true</jk>)
				)
				.response(405, <jsm>responseInfo</jsm>(<js>"Invalid input"</js>))
		);

	<jc>// Serialize to Swagger/JSON</jc>
	String swaggerJson = JsonSerializer.<jsf>DEFAULT_READABLE</jsf>.serialize(swagger);
	</p>
	<p class='bcode'>
	{
		<jf>"swagger"</jf>: <js>"2.0"</js>,
		<jf>"info"</jf>: {
			<jf>"title"</jf>: <js>"Swagger Petstore"</js>,
			<jf>"description"</jf>: <js>"This is a sample server Petstore server."</js>,
			<jf>"version"</jf>: <js>"1.0.0"</js>,
			<jf>"termsOfService"</jf>: <js>"http://swagger.io/terms/"</js>,
			<jf>"contact"</jf>: {
				<jf>"email"</jf>: <js>"apiteam@swagger.io"</js>
			},
			<jf>"license"</jf>: {
				<jf>"name"</jf>: <js>"Apache 2.0"</js>,
				<jf>"url"</jf>: <js>"http://www.apache.org/licenses/LICENSE-2.0.html"</js>
			}
		},
		<jf>"paths"</jf>: {
			<jf>"/pet"</jf>: {
				<jf>"post"</jf>: {
					<jf>"tags"</jf>: [
						<js>"pet"</js>
					],
					<jf>"summary"</jf>: <js>"Add a new pet to the store"</js>,
					<jf>"description"</jf>: <js>""</js>,
					<jf>"operationId"</jf>: <js>"addPet"</js>,
					<jf>"consumes"</jf>: [
						<js>"application/json"</js>,
						<js>"text/xml"</js>
					],
					<jf>"produces"</jf>: [
						<js>"application/json"</js>,
						<js>"text/xml"</js>
					],
					<jf>"parameters"</jf>: [
						{
							<jf>"in"</jf>: <js>"body"</js>,
							<jf>"name"</jf>: <js>"body"</js>,
							<jf>"description"</jf>: <js>"Pet object that needs to be added to the store"</js>,
							<jf>"required"</jf>: <jk>true</jk>
						}
					],
					<jf>"responses"</jf>: {
						<jf>"405"</jf>: {
							<jf>"description"</jf>: <js>"Invalid input"</js>
						}
					}
				}
			}
		},
	}		
	</p>
	<p>
		Note that these DTOs can also be serialized to any of the other supported languages such as JSON or MessagePack!
		And they can be parsed back into their original objects!
	</p>

	<h5 class='toc'>Juneau Server</h5>
	<p>
		The REST server API builds upon the <code>SerializerGroup</code> and <code>ParserGroup</code> classes 
		to provide annotated REST servlets that automatically negotiate the HTTP media types and allow the developer
		to work with requests, responses, headers, path variables, query parameters, and form data as POJOs.
	</p>
	<p>
		The end goal is to provide simple and flexible yet sophisticated REST interfaces that allow POJOs to be automatically represented as 
		different content types depending on whatever the particular need: 
	</p>
	<ul class='spaced-list'>
		<li>HTML for viewing POJOs in easy-to-read format in a browser.
		<li>JSON for interacting through Javascript.
		<li>XML for interacting with other applications.
		<li>RDF for interacting with triple stores.
		<li>URL-Encoding for interacting through HTML forms.
		<li>MessagePack for efficiently transmitting large amounts of data.
	</ul>
	<p>
		A simple example that supports all languages:
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/systemProperties"</js>,
		title=<js>"System properties resource"</js>
	)
	<jk>public class</jk> SystemPropertiesResource <jk>extends</jk> RestServletDefault {
	
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/"</js>)
		<jk>public</jk> Map getSystemProperties(<ja>@Query</ja>(<js>"sort"</js>) <jk>boolean</jk> sort) <jk>throws</jk> Throwable {
			<jk>if</jk> (sort)
				<jk>return new</jk> TreeMap(System.<jsm>getProperties</jsm>());
			<jk>return</jk> System.<jsm>getProperties</jsm>();
		}
	
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/{propertyName}"</js>)
		<jk>public</jk> String getSystemProperty(<ja>@Path</ja> String propertyName) <jk>throws</jk> Throwable {
			<jk>return</jk> System.<jsm>getProperty</jsm>(propertyName);
		}
	
		<ja>@RestMethod</ja>(name=<js>"PUT"</js>, path=<js>"/{propertyName}"</js>, guards=AdminGuard.<jk>class</jk>)
		<jk>public</jk> String setSystemProperty(<ja>@Path</ja> String propertyName, <ja>@Body</ja> String value) {
			System.<jsm>setProperty</jsm>(propertyName, value);
			<jk>return</jk> <js>"OK"</js>;
		}
	
		<ja>@RestMethod</ja>(name=<js>"POST"</js>, path=<js>"/"</js>, guards=AdminGuard.<jk>class</jk>)
		<jk>public</jk> String setSystemProperties(<ja>@Body</ja> java.util.Properties newProperties) {
			System.<jsm>setProperties</jsm>(newProperties);
			<jk>return</jk> <js>"OK"</js>;
		}
	
		<ja>@RestMethod</ja>(name=<js>"DELETE"</js>, path=<js>"/{propertyName}"</js>, guards=AdminGuard.<jk>class</jk>)
		<jk>public</jk> String deleteSystemProperty(<ja>@Path</ja> String propertyName) {
			System.<jsm>clearProperty</jsm>(propertyName);
			<jk>return</jk> <js>"OK"</js>;
		}
	}
	</p>
	<p>
		A more sophisticated example of the same resource using various features, including information
		for fully populating the Swagger documentation, guards for restricting access to particular
		methods, customizing supported content types and serialization options, adding g-zip compression, 
		and adding customized branding for the HTML views.
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/systemProperties"</js>,
		title=<js>"System properties resource"</js>,
		description=<js>"REST interface for performing CRUD operations on system properties."</js>,
		pageLinks=<js>"{up:'$R{requestParentURI}',options:'?method=OPTIONS'}"</js>,
		serializers={
			HtmlDocSerializer.<jk>class</jk>, 
			JsonSerializer.<jk>class</jk>,
			JsonSerializer.Simple.<jk>class</jk>,
			XmlDocSerializer.<jk>class</jk>,
			MsgPackSerializer.<jk>class</jk>
		},
		parsers={
			JsonParser.<jk>class</jk>,
			XmlParser.<jk>class</jk>,
			HtmlParser.<jk>class</jk>,
			MsgPackParser.<jk>class</jk>
		},
		properties={
			<ja>@Property</ja>(name=<jsf>SERIALIZER_quoteChar</jsf>, value=<js>"'"</js>)
		},
		stylesheet=<js>"styles/devops.css"</js>,
		encoders=GzipEncoder.<jk>class</jk>,
		contact=<js>"{name:'John Smith',email:'john@smith.com'}"</js>,
		license=<js>"{name:'Apache 2.0',url:'http://www.apache.org/licenses/LICENSE-2.0.html'}"</js>,
		version=<js>"2.0"</js>,
		termsOfService=<js>"You're on your own."</js>,
		tags=<js>"[{name:'Java',description:'Java utility',externalDocs:{description:'Home page',url:'http://juneau.apache.org'}}]"</js>,
		externalDocs=<js>"{description:'Home page',url:'http://juneau.apache.org'}"</js>
	)
	<jk>public class</jk> SystemPropertiesResource <jk>extends</jk> RestServlet {
	
		<ja>@RestMethod</ja>(
			name=<js>"GET"</js>, path=<js>"/"</js>,
			summary=<js>"Show all system properties"</js>,
			description=<js>"Returns all system properties defined in the JVM."</js>,
			parameters={
				<ja>@Parameter</ja>(in=<js>"query"</js>, name=<js>"sort"</js>, description=<js>"Sort results alphabetically."</js>, _default=<js>"false"</js>)
			},
			responses={
				<ja>@Response</ja>(value=200, description=<js>"Returns a map of key/value pairs."</js>)
			}
		)
		<jk>public</jk> Map getSystemProperties(<ja>@Query</ja>(<js>"sort"</js>) <jk>boolean</jk> sort) <jk>throws</jk> Throwable {
			<jk>if</jk> (sort)
				<jk>return new</jk> TreeMap(System.<jsm>getProperties</jsm>());
			<jk>return</jk> System.<jsm>getProperties</jsm>();
		}
	
		...
	}
	</p>
	<p>
		When combined with the support for HTML5 beans, simple HTML forms can be constructed for easy input and output
		using nothing more than Java:
	</p>
	<p class='bcode'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
	
	<ja>@RestMethod</ja>(
		name=<js>"GET"</js>, path=<js>"/formPage"</js>,
		summary=<js>"Form entry page"</js>,
		description=<js>"A form post page for setting a single system property value."</js>,
		guards=AdminGuard.<jk>class</jk>
	)
	<jk>public</jk> Form getFormPage() {
		<jk>return</jk> <jsm>form</jsm>().method(<js>"POST"</js>).action(<js>"formPagePost"</js>).children(
			<jsm>h4</jsm>(<js>"Set system property"</js>),
			<js>"Name: "</js>, <jsm>input</jsm>(<js>"text"</js>).name(<js>"name"</js>), <jsm>br</jsm>(),
			<js>"Value: "</js>, <jsm>input</jsm>(<js>"text"</js>).name(<js>"value"</js>), <jsm>br</jsm>(), <jsm>br</jsm>(),
			<jsm>button</jsm>(<js>"submit","Click me!"</js>).style(<js>"float:right"</js>)
		);
	}

	<ja>@RestMethod</ja>(
		name=<js>"POST"</js>, path=<js>"/formPagePost"</js>, 
		description=<js>"Accepts a simple form post of a system property name/value pair."</js>,
		guards=AdminGuard.<jk>class</jk>
	)
	<jk>public</jk> Redirect formPagePost(<ja>@FormData</ja>(<js>"name"</js>) String name, <ja>@FormData</ja>(<js>"value"</js>) String value) {
		System.<jsm>setProperty</jsm>(name, value);
		<jk>return new</jk> Redirect();  <jc>// Redirect to the servlet top page.</jc>
	}
	</p>	
	<img class='bordered' src='images/SystemPropertiesForm.png'>
	<p>
		The REST API is built on top of Servlets, making them easy to deploy in any JEE environment.  
		This allows you to use as much or as little of the Juneau technology as you wish.
		For example, if you wish to handle the response yourself, simply add the request and response objects to your method call and use
		the existing Servlet API methods to process the request and send a response:
	</p>
	<p class='bcode'>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/somePath"</js>)
	<jk>public void</jk> doLowLevelStuff(RestRequest req, RestResponse res) {
		<jc>// Do stuff with request and response objects.
		// These are subclasses of HttpServletRequest/HttpServletResponse with lots of
		// additional convenience methods.</jc>
	}
	</p>
	<p>
		REST Java methods can return any of the following objects:  POJOs, Readers, InputStreams, ZipFiles, Redirects, Streamables, and Writables.
		<br>Or add your own handlers for other types.  
	</p>
	<p>
		REST Java methods can be passed any of the following objects in any order:
	</p>
	<ul>
		<li>Low-level request/response objects: HttpServletRequest, HttpServletResponse, RestRequest, RestResponse.
		<li>Path variables and remainder, query parameters, form parameters, HTTP method name, and header values as POJOs.
		<li>Other objects such as a ResourceBundle containing client-localized messages.
	</ul>
	<p>
		All parameter annotations also have programmatic equivalents on the RestRequest object.
		<br>As a general rule, anything done through annotations in Juneau has a programmatic equivalent. 
	</p>
	<p class='bcode'>
		<jd>/** Example GET request using annotated attributes */</jd> 
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/example1/{a1}/{a2}/{a3}/*"</js>) 
		<jk>public</jk> String doGetExample1( 
			<ja>@Method</ja> String method, 
			<ja>@Path</ja> String a1, 
			<ja>@Path</ja> <jk>int</jk> a2, 
			<ja>@Path</ja> UUID a3, 
			<ja>@Query</ja>(<js>"p1"</js>) <jk>int</jk> p1, 
			<ja>@Query</ja>(<js>"p2"</js>) String p2, 
			<ja>@Query</ja>(<js>"p3"</js>) UUID p3, 
			<ja>@PathRemainder</ja> String remainder, 
			<ja>@Header</ja>(<js>"Accept-Language"</js>) String lang, 
			<ja>@Header</ja>(<js>"Accept"</js>) String accept, 
			<ja>@Header</ja>(<js>"DNT"</js>) <jk>int</jk> doNotTrack 
		) { 
			String output = String.format( 
				<js>"method=%s, a1=%s, a2=%d, a3=%s, remainder=%s, p1=%d, p2=%s, p3=%s, lang=%s, accept=%s, dnt=%d"</js>, 
				method, a1, a2, a3, remainder, p1, p2, p3, lang, accept, doNotTrack); 
			<jk>return</jk> output; 
		} 
		
		<jd>/** Example GET request using methods on RestRequest and RestResponse */</jd> 
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/example2/{a1}/{a2}/{a3}/*"</js>) 
		<jk>public void</jk> doGetExample2(RestRequest req, RestResponse res) <jk>throws</jk> Exception { 
			String method = req.getMethod(); 
			
			<jc>// Attributes (from URL pattern variables)</jc> 
			String a1 = req.getPathParameter(<js>"a1"</js>, String.<jk>class</jk>); 
			<jk>int</jk> a2 = req.getPathParameter(<js>"a2"</js>, <jk>int</jk>.<jk>class</jk>); 
			UUID a3 = req.getPathParameter(<js>"a3"</js>, UUID.<jk>class</jk>); 
			
			<jc>// Optional GET parameters</jc> 
			<jk>int</jk> p1 = req.getQueryParameter(<js>"p1"</js>, <jk>int</jk>.<jk>class</jk>); 
			String p2 = req.getQueryParameter(<js>"p2"</js>, String.<jk>class</jk>); 
			UUID p3 = req.getQueryParameter(<js>"p3"</js>, UUID.<jk>class</jk>); 
			
			<jc>// URL pattern post-match</jc> 
			String remainder = req.getPathRemainder(); 
			
			<jc>// Headers</jc> 
			String lang = req.getHeader(<js>"Accept-Language"</js>); 
			<jk>int</jk> doNotTrack = req.getHeader(<js>"DNT"</js>, <jk>int</jk>.<jk>class</jk>); 
			
			<jc>// Send back a simple String response</jc> 
			String output = String.format( 
				<js>"method=%s, a1=%s, a2=%d, a3=%s, remainder=%s, p1=%d, p2=%s, p3=%s, lang=%s, dnt=%d"</js>, 
				method, a1, a2, a3, remainder, p1, p2, p3, lang, doNotTrack); 
			res.setOutput(output); 
		} 
	</p>
	<p>
		Auto-generated OPTIONS pages are constructed from Swagger DTO beans, here shown serialized as HTML:
	</p>
	<img class='bordered' src='images/Swagger.png'>
	<p>
		Swagger documentation can be populated from annotations (as above), resource bundles, or Swagger JSON files.
	</p>
	<p>
		The page shown above is implemented on the RestServletDefault class in the method below which shows that it's doing nothing more than 
		serializing a Swagger bean which is constructed in the RestRequest object:
	</p>
	<p class='bcode'>
	<ja>@RestMethod</ja>(name=<js>"OPTIONS"</js>, path=<js>"/*"</js>)
	<jk>public</jk> Swagger getOptions(RestRequest req) {
		<jk>return</jk> req.getSwagger();
	}
	</p>
	<p>	
		Navigatable hierarchies of REST resources are easy to set up either programmatically or through annotations:
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/"</js>,
		title=<js>"Root resources"</js>,
		description=<js>"This is an example of a router resource that is used to access other resources."</js>,
		pageLinks=<js>"{options:'?method=OPTIONS',source:'$C{Source/gitHub}/org/apache/juneau/rest/example/RootResources.java'}"</js>,
		children={
			HelloWorldResource.<jk>class</jk>,
			SystemPropertiesResource.<jk>class</jk>,
			MethodExampleResource.<jk>class</jk>,
			RequestEchoResource.<jk>class</jk>,
			TempDirResource.<jk>class</jk>,
			AddressBookResource.<jk>class</jk>,
			SampleRemoteableServlet.<jk>class</jk>,
			PhotosResource.<jk>class</jk>,
			AtomFeedResource.<jk>class</jk>,
			JsonSchemaResource.<jk>class</jk>,
			SqlQueryResource.<jk>class</jk>,
			TumblrParserResource.<jk>class</jk>,
			CodeFormatterResource.<jk>class</jk>,
			UrlEncodedFormResource.<jk>class</jk>,
			ConfigResource.<jk>class</jk>,
			LogsResource.<jk>class</jk>,
			DockerRegistryResource.<jk>class</jk>,
			ShutdownResource.<jk>class</jk>
		}
	)
	<jk>public class</jk> RootResources <jk>extends</jk> RestServletGroupDefault { <jc>/* No code needed! */</jc> }
	</p>
	<p>
		The above resource when rendered in HTML shows how easy it is to discover and navigate to child resources using a browser:
	</p>
	<img class='bordered' src='images/Samples_RootResources.png'>
	<p>
		Resources can be nested arbitrarily deep.  
		The <ja>@RestResource</ja> and <ja>@RestMethod</ja> annotations can be applied to any classes, not just
		servlets.  The only requirement is that the top-level resource be a subclass of <code>RestServlet</code> as a hook into
		the servlet container.
	</p>
	<p>
		Automatic error handling is provided for a variety of conditions: 
	</p>
	<ul>
		<li>Automatic 401 errors (Unauthorized) on failed guards.
		<li>Automatic 404 errors (Not Found) on unmatched path patterns.
		<li>Automatic 405 errors (Method Not Implemented) on unimplemented methods.
		<li>Automatic 406 errors (Not Acceptable) when no matching serializer was found to handle the <l>Accept</l> header.
		<li>Automatic 412 errors (Precondition Failed) when all matchers failed to match.
		<li>Automatic 415 errors (Unsupported Media Type) when no matching parser was found was found to handle the <l>Content-Type</l> header.
		<li>Automatic 500 errors on uncaught exceptions.
		<li>Throw your own runtime RestException with HTTP status and response object. 
	</ul>
	<p>
		Other features include: 
	</p> 
	<ul>
		<li>Extremely simple debuggability using nothing more than your browser.
		<li>Simplified localization support.
		<li>Configurability through external INI files.
		<li>Client-versioned responses (and other customizable heuristic matching APIs).
		<li>Define and use your own HTML stylesheets.
		<li>Optional JAX-RS integration.
		<li>Lots of up-to-date documentation and examples.
		<li>MUCH MORE!....
	</ul>

	<h5 class='toc'>Juneau Client</h5>
	<p>
		The REST client API allows you to access REST interfaces using POJOs as well:
	</p>
	<p class='bcode'>
	<jc>// Create a reusable JSON client.</jc>
	RestClient client = <jk>new</jk> RestClientBuilder().build();
	
	<jc>// The address of the root resource.</jc>
	String url = <js>"http://localhost:10000/systemProperties"</js>;
	
	<jc>// Do a REST GET against a remote REST interface and convert
	// the response to an unstructured ObjectMap object.</jc>
	Map m1 = client.doGet(url).getResponse(TreeMap.<jk>class</jk>);
	
	<jc>// Add some new system properties.
	// Use XML as the transport medium.</jc>
	client = <jk>new</jk> RestClientBuilder(XmlSerializer.<jk>class</jk>, XmlParser.<jk>class</jk>).build();
	Properties p = <jk>new</jk> Properties();
	p.load(reader);
	<jk>int</jk> returnCode = client.doPost(url + <js>"/systemProperties"</js>, p).execute();
	</p>
	<p>
		The client API uses the same serializers and parsers (and subsequently their flexibilty and configurability) as the server side to marshall POJOs back and forth.
	</p>
	<br><br><hr>
	<p>
		The remote proxy interface API allows you to invoke server-side POJO methods on the client side using REST (i.e. RPC over REST):
	</p>
	<p class='bcode'>
 	<jc>// Get an interface proxy.</jc>
 	IAddressBook ab = restClient.getRemoteableProxy(IAddressBook.<jk>class</jk>);
	
	<jc>// Invoke a method on the server side and get the returned result.</jc>
	Person p = ab.createPerson(
		<jk>new</jk> Person(
			<js>"John Smith"</js>, 
			<js>"Aug 1, 1999"</js>,
			<jk>new</jk> Address(<js>"My street"</js>, <js>"My city"</js>, <js>"My state"</js>, 12345, <jk>true</jk>)
		)
	);
	</p>
	<p>
		There are two ways to expose remoteable proxies on the server side:
	</p>
	<ol>
		<li>Extending from <code>RemoteableServlet</code>.
		<li>Using a <code><ja>@RestMethod</ja>(name=<js>"PROXY"</js>)</code> annotation on a Java method.
	</ol>
	<p>
		The <code>RemoteableServlet</code> class is a simple specialized servlet with an abstract <code>getServiceMap()</code>
		method to define the server-side POJOs:
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/remote"</js>
	)
	<jk>public class</jk> SampleRemoteableServlet <jk>extends</jk> RemoteableServlet {
	
		<jc>// Our server-side POJO.</jc>
		AddressBook <jf>addressBook</jf> = <jk>new</jk> AddressBook();
	
		<ja>@Override</ja> <jc>/* RemoteableServlet */</jc>
		<jk>protected</jk> Map&lt;Class&lt;?&gt;,Object&gt; getServiceMap() <jk>throws</jk> Exception {
			Map&lt;Class&lt;?&gt;,Object&gt; m = <jk>new</jk> LinkedHashMap&lt;Class&lt;?&gt;,Object&gt;();
	
			<jc>// In this simplified example, we expose the same POJO service under two different interfaces.
			// One is IAddressBook which only exposes methods defined on that interface, and
			// the other is AddressBook itself which exposes all methods defined on the class itself (dangerous!).</jc>
			m.put(IAddressBook.<jk>class</jk>, <jf>addressBook</jf>);
			m.put(AddressBook.<jk>class</jk>, <jf>addressBook</jf>);
			<jk>return</jk> m;
		}
	}
	</p>
	<p>
		The <code><ja>@RestMethod</ja>(name=<js>"PROXY"</js>)</code> approach is easier if you only have a single interface you want to expose.  
		You simply define a Java method whose return type is an interface, and return the implementation of that interface:
	</p>
	<p class='bcode'>
	<jc>// Our exposed proxy object.</jc>
	<ja>@RestMethod</ja>(name=<js>"PROXY"</js>, path=<js>"/addressbookproxy/*"</js>)
	<jk>public</jk> IAddressBook getProxy() {
		<jk>return</jk> addressBook;
	}
	</p>
	<p>
		In either case, the proxy communications layer is pure REST.   
		Parameters passed in on the client side are serialized as an HTTP POST, parsed on the
		server side, and then passed to the invocation method.  The returned POJO is then marshalled back as an HTTP response.
	</p>
	<p>
		In most cases, you'll want to use JSON or MessagePack as your communications layer since these are the most efficent.
		Although remoteable proxies work perfectly well for any of the other supported languages.  For example, RPC over Turtle!
	</p>
	<p>
		The parameters and return types of the Java methods can be any of the supported serializable and parsable types in <a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#Core.PojoCategories'>POJO Categories</a>.
		This ends up being WAY more flexible than other proxy interfaces since Juneau can handle so may POJO types out-of-the-box.
		Most of the time you don't even need to modify your existing Java implementation code.
	</p>
	<p>
		The RemoteableServlet class itself shows how sophisticated REST interfaces can be built on the Juneau RestServlet
		API using very little code.  The RemoteableServlet class itself consists of only 53 lines of code, yet is
		a sophisticated discoverable and self-documenting REST interface.  And since the remote proxy API is built on top 
		of REST, it can be debugged using just a browser.
	</p>
	<br><br><hr>
	<p>
		Remoteable proxies can also be used to define interface proxies against 3rd-party REST interfaces.
		This is an extremely powerful feature that allows you to quickly define easy-to-use interfaces against virtually any REST interface.
	</p>
	<p>
		Similar in concept to remoteable services defined above, but in this case we simply define our interface with
		special annotations that tell us how to convert input and output to HTTP headers, query paramters, form post parameters, or request/response bodies.
	</p>
	<p class='bcode'>	
	<ja>@Remoteable</ja>
	<jk>public interface</jk> MyProxyInterface {
		
		<ja>@RemoteMethod</ja>(httpMethod=<js>"POST"</js>, path=<js>"/method"</js>)
		String doMethod(<ja>@Header</ja>(<js>"E-Tag"</js>) UUID etag, <ja>@Query</ja>(<js>"debug"</js>) <jk>boolean</jk> debug, <ja>@Body</ja> MyPojo pojo);
	}
	
	RestClient client = <jk>new</jk> RestClientBuilder().build();
	MyProxyInterface p = client.getRemoteableProxy(MyProxyInterface.<jk>class</jk>, <js>"http://hostname/some/rest/interface"</js>);
	String response = p.doMethod(UUID.<jsm>generate</jsm>(), <jk>true</jk>, <jk>new</jk> MyPojo());
	</p>

	<h5 class='toc'>Config</h5>
	<p>
		The config file API allows you to interact with INI files using POJOs.  
		A sophisticated variable language is provided for referencing environment variables, system properties, other config file entries, and a host of other types.
	<p>
	<p class='bcode'>
	<cc>#--------------------------</cc>
	<cc># My section</cc>
	<cc>#--------------------------</cc>
	<cs>[MySection]</cs>
	
	<cc># An integer</cc>
	<ck>anInt</ck> = <cv>1</cv> 
	
	<cc># A boolean</cc>
	<ck>aBoolean</ck> = <cv>true</cv>
	
	<cc># An int array</cc>
	<ck>anIntArray</ck> = <cv>1,2,3</cv>
	
	<cc># A POJO that can be converted from a String</cc>
	<ck>aURL</ck> = <cv>http://foo </cv>
	
	<cc># A POJO that can be converted from JSON</cc>
	<ck>aBean</ck> = <cv>{foo:'bar',baz:123}</cv>
	
	<cc># A system property</cc>
	<ck>locale</ck> = <cv>$S{java.locale, en_US}</cv>
	
	<cc># An environment variable</cc>
	<ck>path</ck> = <cv>$E{PATH, unknown}</cv>
	
	<cc># A manifest file entry</cc>
	<ck>mainClass</ck> = <cv>$MF{Main-Class}</cv>
	
	<cc># Another value in this config file</cc>
	<ck>sameAsAnInt</ck> = <cv>$C{MySection/anInt}</cv>
	
	<cc># A command-line argument in the form "myarg=foo"</cc>
	<ck>myArg</ck> = <cv>$ARG{myarg}</cv>
	
	<cc># The first command-line argument</cc>
	<ck>firstArg</ck> = <cv>$ARG{0}</cv>

	<cc># Look for system property, or env var if that doesn't exist, or command-line arg if that doesn't exist.</cc>
	<ck>nested</ck> = <cv>$S{mySystemProperty,$E{MY_ENV_VAR,$ARG{0}}}</cv>

	<cc># A POJO with embedded variables</cc>
	<ck>aBean2</ck> = <cv>{foo:'$ARG{0}',baz:$C{MySection/anInt}}</cv>

		</p>
		<p>
			You're probably wondering "why INI files?"
			The beauty of these INI files is that they're easy to read and modify, yet sophisticated enough to allow you to
			store arbitrary-complex data structures and retrieve them as simple values or complex POJOs:
		</p>
		<p class='bcode'>
	<jc>// Load our config file</jc>
	ConfigFile f = <jk>new</jk> ConfigFileBuilder().build(<js>"MyIniFile.cfg"</js>);
	
	<jk>int</jk> anInt = cf.getInt(<js>"MySection/anInt"</js>); 
	<jk>boolean</jk> aBoolean = cf.getBoolean(<js>"MySection/aBoolean"</js>); 
	<jk>int</jk>[] anIntArray = cf.getObject(<jk>int</jk>[].<jk>class</jk>, <js>"MySection/anIntArray"</js>); 
	URL aURL = cf.getObject(URL.<jk>class</jk>, <js>"MySection/aURL"</js>); 
	MyBean aBean = cf.getObject(MyBean.<jk>class</jk>, <js>"MySection/aBean"</js>); 
	Locale locale = cf.getObject(Locale.<jk>class</jk>, <js>"MySection/locale"</js>); 
	String path = cf.getString(<js>"MySection/path"</js>); 
	String mainClass = cf.getString(<js>"MySection/mainClass"</js>); 
	<jk>int</jk> sameAsAnInt = cf.getInt(<js>"MySection/sameAsAnInt"</js>); 
	String myArg = cf.getString(<js>"MySection/myArg"</js>); 
	String firstArg = cf.getString(<js>"MySection/firstArg"</js>); 
	</p>
	<p>
		One of the more powerful aspects of the REST servlets is that you can pull values directly from
		config files by using the <js>"$C"</js> variable in annotations.
		<br>For example, the HTML stylesheet for your REST servlet can be defined in a config file like so:
	</p>
	<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/myResource"</js>,
		config=<js>"$S{my.config.file}"</js>,  <jc>// Path to config file (here pulled from a system property)</jc>
		stylesheet=<js>"$C{MyResourceSettings/myStylesheet}"</js>  <jc>// Stylesheet location pulled from config file.</jc>
	)
	<jk>public class</jk> MyResource <jk>extends</jk> RestServlet {
	</p>
	<p>
		The Config API also contains a listener API that allows you to, for example, reinitialize your REST
		resource if the config file changes, or listen for changes to particular sections or values.
	</p>
	<p>
		You can also modify INI files through the ConfigFile class (e.g. add/remove/modify sections and keys, add/remove comments and whitespace, etc...).
		<br>When using these APIs, you <b>DO NOT</b> lose formatting in your existing configuration file.
		All existing whitespace and comments are preserved for you!
	</p>

	<h5 class='toc'>Juneau Microservice</h5>
	<p>
		The microservice API combines all the features above with a built-in Jetty server to produce a lightweight 
		REST service packaged as two simple files:
	</p>
	<ul>
		<li>An executable jar file that starts up a REST interface in milliseconds.
		<li>An external INI file that can be used to configure your REST resources on the fly.
	</ul>
	<p>
		The microservice API was originally designed for and particularly suited for use in Docker containers.
	</p>
	<p>
		REST microservices can also be started programmatically in existing code:
	</p>
	<p class='bcode'>
	RestMicroservice myRestService = <jk>new</jk> RestMicroservice().setConfig(<js>"microservice.cfg"</js>, <jk>false</jk>);
	myRestService.start();
	URI uri = myRestService.getURI();
	</p>
	<p>
		The provided microservice.cfg template file gives you a starting point for defining your microservice:
	</p>
	<p class='bcode'>
	<cc>#================================================================================
	# Basic configuration file for SaaS microservices
	# Subprojects can use this as a starting point.
	#================================================================================</cc>
	
	<cc>#================================================================================
	# REST settings
	#================================================================================</cc>
	<cs>[REST]</cs>
	
	<cc># The HTTP port number to use.
	# Can be a comma-delimited list of ports to try.
	# 0 means try a random port.
	# Default is Rest-Port setting in manifest file, or 8000.
	# In this case, try port 10000, then try 3 random ports.</cc>
	<ck>port</ck> = <cv>10000, 0, 0, 0</cv>
	
	<cc># A JSON map of servlet paths to servlet classes.
	# Example:  
	# 	resourceMap = {'/*':'com.foo.MyServlet'}
	# Either resourceMap or resources must be specified.</cc>
	<ck>resourceMap</ck> = 

	<cc># A comma-delimited list of names of classes that extend from Servlet.
	# Resource paths are pulled from @RestResource.path() annotation, or
	# 	"/*" if annotation not specified.
	# Example:  
	# 	resources = com.foo.MyServlet
	# Default is Rest-Resources in manifest file.
	# Either resourceMap or resources must be specified.</cc>
	<ck>resources</ck> = 

	<cc># The context root of the Jetty server.
	# Default is Rest-ContextPath in manifest file, or "/".</cc>
	<ck>contextPath</ck> = 

	<cc># Authentication:  NONE, BASIC.</cc>
	<ck>authType</ck> = <cv>NONE</cv>
	
	<cc># The BASIC auth username.
	# Default is Rest-LoginUser in manifest file.</cc>
	<ck>loginUser</ck> = 
	
	<cc># The BASIC auth password.
	# Default is Rest-LoginPassword in manifest file.</cc>
	<ck>loginPassword</ck> = 
	
	<cc># The BASIC auth realm.
	# Default is Rest-AuthRealm in manifest file.</cc>
	<ck>authRealm</ck> = 
	
	<cc># Stylesheet to use for HTML views.
	# The default options are:
	#  - styles/juneau.css
	#  - styles/devops.css
	# Other stylesheets can be referenced relative to the servlet package or working
	# 	directory.</cc>
	<ck>stylesheet</ck> = <cv>styles/devops.css</cv>
	
	<cc># What to do when the config file is saved.
	# Possible values:
	# 	NOTHING - Don't do anything. 
	#	RESTART_SERVER - Restart the Jetty server.
	#	RESTART_SERVICE - Shutdown and exit with code '3'.</cc>
	<ck>saveConfigAction</ck> = <cv>RESTART_SERVER</cv>
	
	<cc># Enable SSL support.</cc>
	<ck>useSsl</ck> = <cv>true</cv>
	
	<cc>#================================================================================
	# Bean properties on the org.eclipse.jetty.util.ssl.SslSocketFactory class
	#--------------------------------------------------------------------------------
	# Ignored if REST/useSsl is false.
	#================================================================================</cc>
	<cs>[REST-SslContextFactory]</cs>
	<ck>keyStorePath</ck> = <cv>client_keystore.jks</cv>
	<ck>keyStorePassword*</ck> = <cv>{HRAaRQoT}</cv>
	<ck>excludeCipherSuites</ck> = <cv>TLS_DHE.*, TLS_EDH.*</cv>
	<ck>excludeProtocols</ck> = <cv>SSLv3</cv>
	<ck>allowRenegotiate</ck> = <cv>false</cv>
	
	<cc>#================================================================================
	# Logger settings
	# See FileHandler Java class for details.
	#================================================================================</cc>
	<cs>[Logging]</cs>

	<cc># The directory where to create the log file.
	# Default is "."</cc>
	<ck>logDir</ck> = <cv>logs</cv>
	
	<cc># The name of the log file to create for the main logger.
	# The logDir and logFile make up the pattern that's passed to the FileHandler
	# constructor.
	# If value is not specified, then logging to a file will not be set up.</cc>
	<ck>logFile</ck> = <cv>microservice.%g.log</cv>
	
	<cc># Whether to append to the existing log file or create a new one.
	# Default is false.</cc>
	<ck>append</ck> = 
	
	<cc># The SimpleDateFormat format to use for dates.
	# Default is "yyyy.MM.dd hh:mm:ss".</cc>
	<ck>dateFormat</ck> = 
	
	<cc># The log message format.
	# The value can contain any of the following variables:
	# 	{date} - The date, formatted per dateFormat.
	#	{class} - The class name.
	#	{method} - The method name.
	#	{logger} - The logger name.
	#	{level} - The log level name.
	#	{msg} - The log message.
	#	{threadid} - The thread ID.
	#	{exception} - The localized exception message.
	# Default is "[{date} {level}] {msg}%n".</cc>
	<ck>format</ck> =
	
	<cc># The maximum log file size.
	# Suffixes available for numbers.
	# See ConfigFile.getInt(String,int) for details.
	# Default is 1M.</cc>
	<ck>limit</ck> = <cv>10M</cv>
	
	<cc># Max number of log files.
	# Default is 1.</cc>
	<ck>count</ck> = <cv>5</cv>
	
	<cc># Default log levels.
	# Keys are logger names.
	# Values are serialized Level POJOs.</cc>
	<ck>levels</ck> = <cv>{ org.apache.juneau:'INFO' }</cv>
	
	<cc># Only print unique stack traces once and then refer to them by a simple 8 character hash identifier.
	# Useful for preventing log files from filling up with duplicate stack traces.
	# Default is false.</cc>
	<ck>useStackTraceHashes</ck> = <cv>true</cv>
	
	<cc># The default level for the console logger.
	# Default is WARNING.</cc>
	<ck>consoleLevel</ck> = 
	
	<cc>#================================================================================
	# System properties
	#--------------------------------------------------------------------------------
	# These are arbitrary system properties that are set during startup.
	#================================================================================</cc>
	<cs>[SystemProperties]</cs>
	
	<cc># Configure Jetty for StdErrLog Logging</cc>
	<ck>org.eclipse.jetty.util.log.class</ck> = <cv>org.eclipse.jetty.util.log.StrErrLog</cv>
	
	<cc># Jetty logging level</cc>
	<ck>org.eclipse.jetty.LEVEL</ck> = <cv>WARN</cv>		
	</p>
	<p>
		Various predefined reusable REST resource classes are provided for accessing log files, viewing and editing the config file, etc...
		These allow you to quickly put together sophisticated REST microservices.
	</p>

	<h5 class='toc'>More information</h5>
	<p>
		<b>*ALL*</b> user documentation for this project is maintained in its <a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/index.html' target="_top">Javadocs</a>.
		If it's not in the Javadocs, it doesn't exist.
	</p>
	<p>
		The top-level <a class='doclink' href='http://juneau.incubator.apache.org/site/apidocs/overview-summary.html#overview.description' target="_top">Overview</a> document is a good
		starting point for developers wishing to get up-to-speed quickly.
	</p>
	<p align="center"><i><b>*** fi&#769;n ***</b></i></p>
</body>
</html>